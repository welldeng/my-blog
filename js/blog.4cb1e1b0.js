(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["blog"],{"0ec7":function(e,n,t){"use strict";t.r(n),n["default"]='<blockquote>\n<p>最近学习了<font color="blue"><strong>观察者模式</strong></font>和<font color="blue"><strong>发布/订阅模式</strong></font>，但是一直有种不得要领的感觉，今天重新复习了一遍又有了新的思考，记录一下学习收获。</p>\n</blockquote>\n<h2 id="观察者模式">观察者模式</h2>\n<p>概念引用原文的话如下：</p>\n<blockquote>\n<p>The Observer is a design pattern where an object (known as a subject) maintains a list of objects depending on it (observers), automatically notifying them of any changes to state.</p>\n</blockquote>\n<blockquote>\n<p>一个对象（subject）维护一个对象列表（observers），当发生任何状态改变时自动通知它们</p>\n</blockquote>\n<p>根据概念画了一个大概的关系图</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/4/27/16a5de521a4a487a?w=472&h=601&f=png&s=24756" alt=""></p>\n<p>接下来直接看看代码的实现</p>\n<p>先是一个observeList类，这个类有几个维护observerList的方法，这几个方法是用来管理对象维护的观察者列表的方法（类似增删改查）。</p>\n<pre><code>function ObserverList(){\n    this.observerList = [];\n}\n\nObserverList.prototype.add = function( obj ){\n    return this.observerList.push( obj );\n};\n\nObserverList.prototype.count = function(){\n    return this.observerList.length;\n};\n\nObserverList.prototype.get = function( index ){\n    if( index &gt; -1 &amp;&amp; index &lt; this.observerList.length ){\n        return this.observerList[ index ];\n    }\n};\n\nObserverList.prototype.indexOf = function( obj, startIndex ){\n    var i = startIndex;\n\n    while( i &lt; this.observerList.length ){\n        if( this.observerList[i] === obj ){\n            return i;\n        }\n        i++;\n    }\n\n    return -1;\n};\n\nObserverList.prototype.removeAt = function( index ){\n    this.observerList.splice( index, 1 );\n};</code></pre><p>接下来是subject类，用于给某个具体的被观察的对象继承，这个类有包装了新增观察者（addObserver）、移除观察者（removeObserver）以及通知观察者（notify）的方法。</p>\n<pre><code>function Subject(){\n    this.observers = new ObserverList();\n}\n\nSubject.prototype.addObserver = function( observer ){\n    this.observers.add( observer );\n};\n\nSubject.prototype.removeObserver = function( observer ){\n    this.observers.removeAt( this.observers.indexOf( observer, 0 ) );\n};\n\nSubject.prototype.notify = function( context ){\n    var observerCount = this.observers.count();\n    for(var i=0; i &lt; observerCount; i++){\n        this.observers.get(i).update( context );\n    }\n};</code></pre><p>最后是一个观察者的类，这个其实并不是强制要求以这个类来实现，只是说明了观察者需要暴露一个update方法，当subject的实例发生变化时，subject实例使用notify方法去调用观察者的update方法。</p>\n<pre><code>function Observer(){\n    this.update = function(){\n        // ...\n    };\n}</code></pre><p>刚开始看观察者模式的时候一直不是很明白这个设计在开发中的应用，今天又重新看的时候忽然想起来和之前看vue的双向绑定一部分的实现很像。在双向绑定里当我们改变一个对象的值的时候，其他使用了这个值的地方也会对应改变，这和观察者模式的设计是比较类似的。</p>\n<h2 id="发布订阅模式">发布/订阅模式</h2>\n<p>发布/订阅模式和观察者模式有点类似，但是发布/订阅模式不存在观察者与被观察者的关系，这种设计模式相对于观察者模式更加的松耦合，实现代码如下：</p>\n<p>一个对象如果提供了支持Publish()、Subscribe()和unsubscribe()的功能实现，就可以使用Publish/Subscribe。</p>\n<pre><code>var pubsub = {};\n\n(function(myObject) {\n\n    // Storage for topics that can be broadcast\n    // or listened to\n    var topics = {};\n\n    // A topic identifier\n    var subUid = -1;\n\n    // Publish or broadcast events of interest\n    // with a specific topic name and arguments\n    // such as the data to pass along\n    myObject.publish = function( topic, args ) {\n\n        if ( !topics[topic] ) {\n            return false;\n        }\n\n        var subscribers = topics[topic],\n            len = subscribers ? subscribers.length : 0;\n\n        while (len--) {\n            subscribers[len].func( topic, args );\n        }\n\n        return this;\n    };\n\n    // Subscribe to events of interest\n    // with a specific topic name and a\n    // callback function, to be executed\n    // when the topic/event is observed\n    myObject.subscribe = function( topic, func ) {\n\n        if (!topics[topic]) {\n            topics[topic] = [];\n        }\n\n        var token = ( ++subUid ).toString();\n        topics[topic].push({\n            token: token,\n            func: func\n        });\n        return token;\n    };\n\n    // Unsubscribe from a specific\n    // topic, based on a tokenized reference\n    // to the subscription\n    myObject.unsubscribe = function( token ) {\n        for ( var m in topics ) {\n            if ( topics[m] ) {\n                for ( var i = 0, j = topics[m].length; i &lt; j; i++ ) {\n                    if ( topics[m][i].token === token ) {\n                        topics[m].splice( i, 1 );\n                        return token;\n                    }\n                }\n            }\n        }\n        return this;\n    };\n}( pubsub ));</code></pre><p>发布/订阅模式和vue的eventBus异曲同工，在实际应用中，因为任何地方我们都可以订阅（subscribe）一个事件，也可以在任何地方发布（public）一个事件，所以在这个设计模式中，谁发布或者谁订阅了事件是无法感知的，这也是和观察者模式最大的区别。</p>\n<h2 id="总结">总结</h2>\n<p>刚开始学习观察者模式和发布/订阅模式真的是完全没有什么感觉，简单的说的就是代码都看懂了，但是不知道有什么用。今天重新看了一遍，仔细想了一下设计的用法，和实际开发中对应起来就特别有感觉了，学习设计模式对于我们阅读源码和开发中体会框架的设计理念非常有帮助。</p>\n<hr>\n<p>参考文档：<a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#observerpatternjavascript">https://addyosmani.com/resources/essentialjsdesignpatterns/book/#observerpatternjavascript</a></p>\n'},"112e":function(e,n,t){"use strict";t.r(n),n["default"]='<blockquote>\n<p>图片在前端开发中非常常用，但是图片的文件格式却是有很多种，平常我们使用的时候可能不会太在意这方面。实际上不同的图片格式有不同的应用的场景，从体验和性能优化的角度考虑也是值得我们学习。下面将简单介绍图片的常见类型。</p>\n</blockquote>\n<h2 id="图片类型介绍">图片类型介绍</h2>\n<h3 id="1png">1.PNG</h3>\n<p>PNG格式有8位、24位、32位三种形式，其中8位PNG支持两种不同的透明形式（索引透明和alpha透明），24位PNG不支持透明，32位PNG在24位基础上增加了8位透明通道，因此可展现256级透明程度。</p>\n<p>PNG图片支持无损压缩。</p>\n<h3 id="2jpg（jpeg）">2.JPG（JPEG）</h3>\n<p>JPG和JPEG其实是一个格式，而且可细分为Baseling-JPG和Progress-JPG两种。两种不同类型的图片各有适用场景，通常来说使用Progress—JPG给用户的体验更好。</p>\n<p>JPG支持有损压缩。</p>\n<ol>\n<li>Baseling-JPG\n<img src="https://user-gold-cdn.xitu.io/2019/5/25/16aee808d26687af?w=310&h=248&f=gif&s=48572" alt=""></li>\n<li>Progressive-JPG\n<img src="https://user-gold-cdn.xitu.io/2019/5/25/16aee80dcf7cd3b8?w=310&h=248&f=gif&s=104715" alt=""></li>\n</ol>\n<h3 id="3gif">3.GIF</h3>\n<p>GIF经常用于动画的图片上，支持无损压缩，支持背景透明。</p>\n<h3 id="4svg">4.SVG</h3>\n<p>SVG（可缩放矢量图形）这种图片的类型我们可能用得比较少，实际上这种格式的图片优势非常多。</p>\n<ol>\n<li>基于可扩展标记语言</li>\n<li>采用文本来描述对象</li>\n<li>具有交互性和动态性</li>\n<li>完全支持DOM</li>\n</ol>\n<p>SVG支持无损压缩和背景透明，而且还支持动画。</p>\n<p>但是，SVG相比JPG和PNG来说优势这么大为何并没有很广泛的被应用呢？这和SVG的一部分优势相关，因为SVG太过灵活，实际开发中维护SVG图片成本非常高。</p>\n<h3 id="5webp">5.WebP</h3>\n<p>WebP是谷歌开发出来的一种图片格式，所以并不是一个通常的标准格式（仅Chrome和Opera支持）。但是WebP因为其自家谷歌浏览器的份额高占有率，同时WebP相比其他常用的图片格式具有更大的优势，实际开发应用还是比较常见。</p>\n<p>WebP同时支持无损和有损压缩，支持背景透明。</p>\n<h3 id="6apng">6.APNG</h3>\n<p>APNG其实是在PNG的基础上扩展了支持动画的图片文件格式，这也不是一个通用的标准格式（仅Safari和Firefox支持）。</p>\n<p>APNG支持无损压缩，背景透明，且额外支持动画。</p>\n<h3 id="7bpg">7.BPG</h3>\n<p>BPG是一种实验性的图片文件格式，在浏览器使用需要提供js解码，该图片格式并未成为通用标准。但是因为其相比其他图片格式，具有更高压缩比，且支持背景透明和动画，同时支持无损压缩和有损压缩，实际上有希望成为新的主流图片格式。</p>\n<h2 id="有损压缩和无损压缩">有损压缩和无损压缩</h2>\n<p>前面介绍图片的时候提到的无损压缩和有损压缩是什么呢？实际上这个概念适用很多地方（视频，音频等），简单说说这两个的概念。</p>\n<p>1.有损压缩</p>\n<p>有损压缩是利用了人类对图像或声波中的某些频率成分不敏感的特性，允许压缩过程中损失一定的信息；虽然不能完全恢复原始数据，但是所损失的部分对理解原始图像的影响缩小，却换来了大得多的压缩比。</p>\n<p>2.无损压缩</p>\n<p>无损压缩格式，是利用数据的统计冗余进行压缩，可完全恢复原始数据而不引起任何失真。</p>\n<blockquote>\n<p>图片里有损压缩牺牲了部分图片细节，以此换来更大的压缩比。</p>\n</blockquote>\n<h2 id="小结">小结</h2>\n<table>\n<thead>\n<tr>\n<th>图片格式</th>\n<th>支持透明</th>\n<th>支持动画</th>\n<th>压缩方式</th>\n<th>浏览器支持</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PNG</td>\n<td>支持</td>\n<td>不支持</td>\n<td>无损压缩</td>\n<td>所有</td>\n<td>需要透明时</td>\n</tr>\n<tr>\n<td>JPG</td>\n<td>不支持</td>\n<td>不支持</td>\n<td>有损压缩</td>\n<td>所有</td>\n<td>通用场景</td>\n</tr>\n<tr>\n<td>GIF</td>\n<td>支持</td>\n<td>支持</td>\n<td>无损压缩</td>\n<td>所有</td>\n<td>简单颜色、动画</td>\n</tr>\n<tr>\n<td>SVG</td>\n<td>支持</td>\n<td>支持</td>\n<td>无损压缩</td>\n<td>所有</td>\n<td>需要良好缩放体验，动态控制图片特效</td>\n</tr>\n<tr>\n<td>WebP</td>\n<td>支持</td>\n<td>不支持</td>\n<td>有损压缩和无损压缩</td>\n<td>Chrome、Opera</td>\n<td>复杂颜色、平台可知</td>\n</tr>\n<tr>\n<td>APNG</td>\n<td>支持</td>\n<td>支持</td>\n<td>无损压缩</td>\n<td>Firefox、Safari</td>\n<td>半透明动画</td>\n</tr>\n<tr>\n<td>BPG</td>\n<td>支持</td>\n<td>支持</td>\n<td>有损压缩和无损压缩</td>\n<td>无，需要JS解码</td>\n<td>极致性能优化</td>\n</tr>\n</tbody></table>\n<p>在开发中虽然经常用到了图片，但是对不同的图片格式并没有太多认知，希望通过重新学习图片的知识，增强自己的业务能力。</p>\n'},1173:function(e,n){e.exports=function(e,n,t,o){if(!(e instanceof n)||void 0!==o&&o in e)throw TypeError(t+": incorrect invocation!");return e}},"1c4f":function(e,n,t){var o={"./CSS容易忽略的一些知识点.md":"83db","./HTTP协议从0.9-2.0的变化.md":"d6d6","./ 理解JS的event loop.md":"a522","./一篇文章带你理解HTTP缓存.md":"b8c8","./前端的安全问题与防御策略.md":"1dd9","./前端跨域的解决方案.md":"69b0","./学习node Assert + mocha + should断言测试，travis-CI持续集成项目.md":"8bff","./学习valueOf和toString，理解隐式转化规则.md":"9346","./学习vue-router源码记录-1.md":"d424","./学习vue-router源码记录-2.md":"24f8","./学习vue-router源码记录-3.md":"9c25","./学习vuex源码.md":"6214","./学习vue源码—mvvm.md":"63b7","./学习vue源码—nextTick.md":"c25e","./学习vue源码—vue-diff.md":"f45e","./学习观察者模式与发布-订阅模式.md":"0ec7","./深入学习正则表达式.md":"b0f1","./理解__proto__和prototype.md":"26a0","./重新认识前端开发使用的『图片』.md":"112e"};function r(e){var n=c(e);return t(n)}function c(e){var n=o[e];if(!(n+1)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n}r.keys=function(){return Object.keys(o)},r.resolve=c,e.exports=r,r.id="1c4f"},"1dd9":function(e,n,t){"use strict";t.r(n),n["default"]='<blockquote>\n<p>在前端的开发中，安全是我们必须要了解的一环，即使前端很难说有真正的安全，但是了解这些攻击有助于我们如何去规避问题，毕竟安全问题都是需要提前预防，而不能等到真正发生的时候才来解决。</p>\n</blockquote>\n<h2 id="clickjacking（点击劫持）">ClickJacking（点击劫持）</h2>\n<p>1.什么是ClickJacking？</p>\n<p><font color="blue">ClickJacking（点击劫持）</font>是一种视觉上的欺骗手段。大概有两种方式，一是攻击者使用一个透明的iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，此时用户将在不知情的情况下点击透明的iframe页面；二是攻击者使用一张图片覆盖在网页，遮挡网页原有位置的含义。</p>\n<p>2.如何防御ClickJacking</p>\n<p>对于第一种情况我们可以通过设置http响应头标记X-Frame-Option来防止点击劫持。</p>\n<p><font color="blue">X-Frame-Options</font>：X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在&lt;frame&gt;,&lt;iframe&gt;或者&lt;object&gt;中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。\n| 标记值 | 说明 |\n|---|---|\n|DENY|表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。|\n|SAMEORIGIN|表示该页面可以在相同域名页面的 frame 中展示。|\n|ALLOW-FROM uri|表示该页面可以在指定来源的 frame 中展示。|</p>\n<p>除此之外我们还可以使用CSP（Content-Security-Policy）里的frame-ancestors或frame-src来指定页面允许嵌入哪些页面。</p>\n<p>对于不使用X-Frame—Options或CSP，参考网上的解决方法，在打开页面的时候检查一下window.top和window.self是否相等来决定是否重定向。</p>\n<pre><code>if (window.self != window.top) {\n    top.location.href = self.location.href\n}</code></pre><p>至于第二种情况使用图片遮挡网页原有位置的含义，这种站点本身就是一个恶意站点，而不是来自第三方的攻击，这里不做讨论。</p>\n<h2 id="csrf（跨站伪造请求）">CSRF（跨站伪造请求）</h2>\n<p>1.什么是CSRF？</p>\n<p><font color="blue">CSRF（跨站伪造请求）</font>全称为 Cross-site request forgery，CSRF是通过伪装成受信任用户的请求来利用受信任的网站。例如：一位用户在站点A登录了，并且站点A把信息存储在用户本地，之后当用户打开站点B，站点B的恶意代码窃取了这位用户在站点A的个人用户信息，就可以假装成这位用户去请求站点A。</p>\n<p>2.如何防御CSRF</p>\n<ul>\n<li>cookie不存储重要信息</li>\n<li>cookie设置httpOnly，secure，此外path和domain尽量不使用默认值</li>\n<li>cookie设置SameSite（这个属性还不是一个规范，不确定是否有用）</li>\n<li>服务端增加多重安全校验</li>\n<li>使用https协议或其他安全协议发送请求</li>\n</ul>\n<h2 id="xss（跨站脚本攻击）">XSS（跨站脚本攻击）</h2>\n<p>1.什么是XSS？</p>\n<p><font color="blue">XSS（跨站脚本攻击）</font>全称为Cross Site Scripting，为了和CSS文件（Cascading Style Sheets）区分，故称为XSS。XSS通过往Web页面插入恶意代码，当用户访问该页面时，执行嵌入的恶意代码，以此来达到恶意攻击用户的目的。</p>\n<p>XSS攻击又分为存储型和反射型。</p>\n<p>存储型：一般是指我们页面中表单提交的数据存在恶意代码被存储到数据库中。</p>\n<p>反射型：需要欺骗用户自己去点击链接才能触发XSS代码</p>\n<p>2.如何防御XSS</p>\n<ul>\n<li>CSP（Content-Security-Policy）</li>\n</ul>\n<p><font color="blue">CSP（Content-Security-Policy）</font>允许站点管理者在指定的页面控制用户代理的资源。</p>\n<p>设置CSP可以极大程度上提高页面安全，CSP允许我们设置一套非常完善的资源允许请求规则，在此只大概罗列几个。</p>\n<table>\n<thead>\n<tr>\n<th>标记值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>script-src</td>\n<td>限制javascript 源。</td>\n</tr>\n<tr>\n<td>style-src</td>\n<td>限制层叠样式表文件源。</td>\n</tr>\n<tr>\n<td>img-src</td>\n<td>限制图片和图标源。</td>\n</tr>\n<tr>\n<td>media-src</td>\n<td>限制通过&lt;audio&gt; 或&lt;video&gt; 标签加载的媒体文件源。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>SRI（Subresource Integrity）</li>\n</ul>\n<p>在项目中我们可能会引入一些第三方的文件，因为文件在第三方的服务器里，理论上第三方是有可能篡改文件对使用第三方的文件的站点进行攻击。在这种情况下我们可以使用SRI来保证我们引入的文件不被篡改。</p>\n<p><font color="blue">SRI（子资源完整性 Subresource Integrity ）</font>用于让浏览器检查所下载的来自第三方的资源（例如 CDN）未被恶意篡改。它使用哈希值检查确保第三方资源的完整性。只要开发者提供了被需下载资源的哈希值，浏览器就可以检查实际下载的文件是否与预期的哈希值匹配。</p>\n<p>如何使用SRI？只需给 script 或 style 标签添加<font color="red" size="4">integrity</font>属性即可。</p>\n<pre><code>&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;shaxxx-xxxxxx&quot; src=&quot;xxx.com/xxx.js&quot;&gt;&lt;/script&gt;</code></pre><p>要注意的是因为浏览器需要下载资源内容进行计算，所以如果引用第三方的文件需要第三方服务器支持<font>跨域请求（CORS）</font>，客户端则需要加上<font color="red" size="4">crossorigin=&quot;anonymous&quot;</font>属性。</p>\n<p>另外，我们还可以使用CSP设置<font color="red" size="4">require-sri-for</font>强制页面请求js或css文件使用SRI。</p>\n<ul>\n<li>X-XSS-Protection</li>\n</ul>\n<p><font color="blue">X-XSS-Protection</font>响应头是浏览器检测到页面存在XSS攻击时，设置浏览器的行为。通常默认值为1，检测到XSS攻击浏览器将会删除不安全的部分。</p>\n<table>\n<thead>\n<tr>\n<th>标记值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>禁止XSS过滤。</td>\n</tr>\n<tr>\n<td>1</td>\n<td>启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。</td>\n</tr>\n<tr>\n<td>1; mode=block</td>\n<td>启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。</td>\n</tr>\n<tr>\n<td>1; report=&lt;reporting-uri&gt;</td>\n<td>启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。</td>\n</tr>\n</tbody></table>\n<ul>\n<li>对提交的数据encode或过滤</li>\n</ul>\n<p>在页面里提交的数据需要存储到数据库的场景下，我们需要对提交的数据进行encode或者某些特殊字符进行过滤，特别是某些数据我们需要用在src或href里使用的情况。</p>\n<p>除此之外，富文本也是XSS经常发生的重灾区，对于富文本提交的数据是一定要进行过滤的。</p>\n<h2 id="总结">总结</h2>\n<p>上文所述基本上是我们前端里常见的安全问题，其实对于前端来说很难有真正的安全所言，毕竟我们的代码都是明文跑在浏览器上。</p>\n<p>而现在基本上不使用https协议的请求全部都是不安全的，对于页面上数据提交进行过滤校验也是常规操作，大部分场景我们都是使用浏览器的机制来帮助我们防御攻击，增加第三方攻击的成本。</p>\n'},"24c5":function(e,n,t){"use strict";var o,r,c,i,d=t("b8e3"),s=t("e53d"),a=t("d864"),l=t("40c3"),p=t("63b6"),u=t("f772"),h=t("79aa"),f=t("1173"),g=t("a22a"),m=t("f201"),b=t("4178").set,v=t("aba2")(),x=t("656e"),w=t("4439"),y=t("bc13"),k=t("cd78"),S="Promise",q=s.TypeError,T=s.process,_=T&&T.versions,V=_&&_.v8||"",E=s[S],O="process"==l(T),C=function(){},j=r=x.f,P=!!function(){try{var e=E.resolve(1),n=(e.constructor={})[t("5168")("species")]=function(e){e(C,C)};return(O||"function"==typeof PromiseRejectionEvent)&&e.then(C)instanceof n&&0!==V.indexOf("6.6")&&-1===y.indexOf("Chrome/66")}catch(o){}}(),R=function(e){var n;return!(!u(e)||"function"!=typeof(n=e.then))&&n},I=function(e,n){if(!e._n){e._n=!0;var t=e._c;v(function(){var o=e._v,r=1==e._s,c=0,i=function(n){var t,c,i,d=r?n.ok:n.fail,s=n.resolve,a=n.reject,l=n.domain;try{d?(r||(2==e._h&&L(e),e._h=1),!0===d?t=o:(l&&l.enter(),t=d(o),l&&(l.exit(),i=!0)),t===n.promise?a(q("Promise-chain cycle")):(c=R(t))?c.call(t,s,a):s(t)):a(o)}catch(p){l&&!i&&l.exit(),a(p)}};while(t.length>c)i(t[c++]);e._c=[],e._n=!1,n&&!e._h&&D(e)})}},D=function(e){b.call(s,function(){var n,t,o,r=e._v,c=M(e);if(c&&(n=w(function(){O?T.emit("unhandledRejection",r,e):(t=s.onunhandledrejection)?t({promise:e,reason:r}):(o=s.console)&&o.error&&o.error("Unhandled promise rejection",r)}),e._h=O||M(e)?2:1),e._a=void 0,c&&n.e)throw n.v})},M=function(e){return 1!==e._h&&0===(e._a||e._c).length},L=function(e){b.call(s,function(){var n;O?T.emit("rejectionHandled",e):(n=s.onrejectionhandled)&&n({promise:e,reason:e._v})})},N=function(e){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=e,n._s=2,n._a||(n._a=n._c.slice()),I(n,!0))},G=function(e){var n,t=this;if(!t._d){t._d=!0,t=t._w||t;try{if(t===e)throw q("Promise can't be resolved itself");(n=R(e))?v(function(){var o={_w:t,_d:!1};try{n.call(e,a(G,o,1),a(N,o,1))}catch(r){N.call(o,r)}}):(t._v=e,t._s=1,I(t,!1))}catch(o){N.call({_w:t,_d:!1},o)}}};P||(E=function(e){f(this,E,S,"_h"),h(e),o.call(this);try{e(a(G,this,1),a(N,this,1))}catch(n){N.call(this,n)}},o=function(e){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},o.prototype=t("5c95")(E.prototype,{then:function(e,n){var t=j(m(this,E));return t.ok="function"!=typeof e||e,t.fail="function"==typeof n&&n,t.domain=O?T.domain:void 0,this._c.push(t),this._a&&this._a.push(t),this._s&&I(this,!1),t.promise},catch:function(e){return this.then(void 0,e)}}),c=function(){var e=new o;this.promise=e,this.resolve=a(G,e,1),this.reject=a(N,e,1)},x.f=j=function(e){return e===E||e===i?new c(e):r(e)}),p(p.G+p.W+p.F*!P,{Promise:E}),t("45f2")(E,S),t("4c95")(S),i=t("584a")[S],p(p.S+p.F*!P,S,{reject:function(e){var n=j(this),t=n.reject;return t(e),n.promise}}),p(p.S+p.F*(d||!P),S,{resolve:function(e){return k(d&&this===i?E:this,e)}}),p(p.S+p.F*!(P&&t("4ee1")(function(e){E.all(e)["catch"](C)})),S,{all:function(e){var n=this,t=j(n),o=t.resolve,r=t.reject,c=w(function(){var t=[],c=0,i=1;g(e,!1,function(e){var d=c++,s=!1;t.push(void 0),i++,n.resolve(e).then(function(e){s||(s=!0,t[d]=e,--i||o(t))},r)}),--i||o(t)});return c.e&&r(c.v),t.promise},race:function(e){var n=this,t=j(n),o=t.reject,r=w(function(){g(e,!1,function(e){n.resolve(e).then(t.resolve,o)})});return r.e&&o(r.v),t.promise}})},"24f8":function(e,n,t){"use strict";t.r(n),n["default"]="<blockquote>\n<p>继上一遍文章大概介绍了vue-router里面的概念，这一篇文章主要详细介绍路由跳转中发生了什么。</p>\n</blockquote>\n<p> 路由跳转执行的代码主要在<code>./base.js</code>文件里，详细看<code>transitionTo</code>方法。</p>\n<pre><code>transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const route = this.router.match(location, this.current)\n    this.confirmTransition(route, () =&gt; {\n      this.updateRoute(route)\n      onComplete &amp;&amp; onComplete(route)\n      this.ensureURL()\n\n      // fire ready cbs once\n      if (!this.ready) {\n        this.ready = true\n        this.readyCbs.forEach(cb =&gt; { cb(route) })\n      }\n    }, err =&gt; {\n      if (onAbort) {\n        onAbort(err)\n      }\n      if (err &amp;&amp; !this.ready) {\n        this.ready = true\n        this.readyErrorCbs.forEach(cb =&gt; { cb(err) })\n      }\n    })\n  }</code></pre><p><code>transitionTo</code>代码非常简单，执行<code>this.route.match</code>，通过比较新的路由和就得路由拿到一个<code>route</code>对象，然后执行<code>confirmTransition</code>确认路由跳转。</p>\n<p>下面看看这个<code>route</code>对象的定义</p>\n<pre><code>declare type Route = {\n  path: string;\n  name: ?string;\n  hash: string;\n  query: Dictionary&lt;string&gt;;\n  params: Dictionary&lt;string&gt;;\n  fullPath: string;\n  matched: Array&lt;RouteRecord&gt;;\n  redirectedFrom?: string;\n  meta?: any;\n}</code></pre><p>对照代码，我们主要看<code>matched</code>这个属性，在上一篇文章里面已经介绍过<code>RouteRecord</code>对象的定义。路由一开始会执行<code>createMatcher</code>生成一个路由映射表，因此<code>matched</code>里面存放就是我们<font color=red>将要跳转到的路由匹配上的路由配置对象</font>。</p>\n<p>举一个简单的例子说明：</p>\n<pre><code>[{\n    path: &#39;/parent&#39;,\n    component: Parent,\n    children: [\n    { path: &#39;foo&#39;, component: Foo },\n    { path: &#39;bar&#39;, component: Bar },\n    ],\n}]</code></pre><p>假设我们配置了以下的路由，<code>createMatcher</code>会生成根据path建立的映射表</p>\n<pre><code>pathMap = {\n    &#39;/parent&#39;: RouteRecord,\n    &#39;/parent/foo&#39;: RouteRecord,\n    &#39;/parent/bar&#39;: RouteRecord,\n}</code></pre><p>假如我们发生了一个从<code>/parent</code>路由跳转到<code>/parent/foo</code>路由，首先执行以下代码生成的<code>route</code>对象</p>\n<pre><code>const route = this.router.match(location, this.current)</code></pre><p>因此根据我们假设的配置，这里的<code>route</code>里的<code>matched</code>将会包含<code>/parent</code>和<code>/parent/foo</code>的<code>RouteRecord</code>。至于具体的<code>match</code>方法代码就不详细解释了。</p>\n<p>继续讲路由的跳转，生成<code>route</code>对象后将会执行一个确认的方法<code>confirmTransition</code>。</p>\n<p>由于这个方法代码比较长，我们拆开来说明，首先看这个方法的入参说明，接受三个参数，<code>route</code>对象在前面已经生成过了，另外两个是执行完成的回调方法和退出的回调方法。</p>\n<pre><code>confirmTransition (route: Route, onComplete: Function, onAbort?: Function)</code></pre><p>在代码的一开始首先判断当前路由与跳转的路由是否是同一个路由，如果是则直接退出。</p>\n<pre><code>    const current = this.current\n    const abort = err =&gt; {\n      if (isError(err)) {\n        if (this.errorCbs.length) {\n          this.errorCbs.forEach(cb =&gt; { cb(err) })\n        } else {\n          warn(false, &#39;uncaught error during route navigation:&#39;)\n          console.error(err)\n        }\n      }\n      onAbort &amp;&amp; onAbort(err)\n    }\n    if (\n      isSameRoute(route, current) &amp;&amp;\n      // in the case the route map has been dynamically appended to\n      route.matched.length === current.matched.length\n    ) {\n      this.ensureURL()\n      return abort()\n    }\n</code></pre><p>这里的<code>ensureURL</code>方法定义在<code>HTML5History</code>的原型链上，实际上执行的是保存路由变化历史记录，根据<code>push</code>是<code>true</code>或<code>false</code>来确定执行<code>pushState</code>还是<code>replaceState</code>。这一方法在执行完路由跳转后同样会执行一次。</p>\n<pre><code>  HTML5History.prototype.ensureURL = function ensureURL (push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };</code></pre><p>继续看后面的代码，首先通过<code>resolveQueue</code>对比<code>this.current</code>和<code>route</code>对象的<code>matched</code>提取三种变化的组件队列。根据命名我们直接可得知<code>updated</code>、<code>deactivated</code>、<code>activated</code>分别对应更新的组件、失效的组件、激活的组件。然后生成一个需要执行方法的队列<code>queue</code>，根据这个队列的生成定义，我们可以看出执行方法的顺序，至于通过<code>extractLeaveGuards</code>和<code>extractUpdateHooks</code>方法提取组件里的守卫函数就不细说了。</p>\n<ol>\n<li><p>在失活的组件里调用离开守卫。</p>\n</li>\n<li><p>调用全局的 beforeEach 守卫。</p>\n</li>\n<li><p>在重用的组件里调用 beforeRouteUpdate 守卫</p>\n</li>\n<li><p>在激活的路由配置里调用 beforeEnter。</p>\n</li>\n<li><p>解析异步路由组件。</p>\n</li>\n</ol>\n<pre><code>    const {\n      updated,\n      deactivated,\n      activated\n    } = resolveQueue(this.current.matched, route.matched)\n\n    const queue: Array&lt;?NavigationGuard&gt; = [].concat(\n      // in-component leave guards\n      extractLeaveGuards(deactivated),\n      // global before hooks\n      this.router.beforeHooks,\n      // in-component update hooks\n      extractUpdateHooks(updated),\n      // in-config enter guards\n      activated.map(m =&gt; m.beforeEnter),\n      // async components\n      resolveAsyncComponents(activated)\n    )</code></pre><p>看看<code>resolveQueue</code>是如何提取变化的组件。比较<code>current</code>和<code>next</code>确定一个变化的位置<code>i</code>，<code>next</code>里的从<code>0</code>到<code>i</code>则是<code>updated</code>的部分，<code>i</code>之后的则是<code>activated</code>的部分，而<code>current</code>里<code>i</code>之后的则是<code>deactivated</code>的部分。</p>\n<pre><code>function resolveQueue (\n  current: Array&lt;RouteRecord&gt;,\n  next: Array&lt;RouteRecord&gt;\n): {\n  updated: Array&lt;RouteRecord&gt;,\n  activated: Array&lt;RouteRecord&gt;,\n  deactivated: Array&lt;RouteRecord&gt;\n} {\n  let i\n  const max = Math.max(current.length, next.length)\n  for (i = 0; i &lt; max; i++) {\n    if (current[i] !== next[i]) {\n      break\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  }\n}</code></pre><p>接下来就是生成迭代器方法<code>iterator</code>，执行<code>runQueue</code>方法。</p>\n<pre><code>    this.pending = route\n    const iterator = (hook: NavigationGuard, next) =&gt; {\n      if (this.pending !== route) {\n        return abort()\n      }\n      try {\n        hook(route, current, (to: any) =&gt; {\n          if (to === false || isError(to)) {\n            // next(false) -&gt; abort navigation, ensure current URL\n            this.ensureURL(true)\n            abort(to)\n          } else if (\n            typeof to === &#39;string&#39; ||\n            (typeof to === &#39;object&#39; &amp;&amp; (\n              typeof to.path === &#39;string&#39; ||\n              typeof to.name === &#39;string&#39;\n            ))\n          ) {\n            // next(&#39;/&#39;) or next({ path: &#39;/&#39; }) -&gt; redirect\n            abort()\n            if (typeof to === &#39;object&#39; &amp;&amp; to.replace) {\n              this.replace(to)\n            } else {\n              this.push(to)\n            }\n          } else {\n            // confirm transition and pass on the value\n            next(to)\n          }\n        })\n      } catch (e) {\n        abort(e)\n      }\n    }\n\n    runQueue(queue, iterator, () =&gt; {\n      const postEnterCbs = []\n      const isValid = () =&gt; this.current === route\n      // wait until async components are resolved before\n      // extracting in-component enter guards\n      const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid)\n      const queue = enterGuards.concat(this.router.resolveHooks)\n      runQueue(queue, iterator, () =&gt; {\n        if (this.pending !== route) {\n          return abort()\n        }\n        this.pending = null\n        onComplete(route)\n        if (this.router.app) {\n          this.router.app.$nextTick(() =&gt; {\n            postEnterCbs.forEach(cb =&gt; { cb() })\n          })\n        }\n      })\n    })</code></pre><p><code>runQueue</code>方法的代码并不复杂，一个递归执行队列的方法，使用<code>iterator(fn参数)</code>执行<code>queue</code>，<code>iterator</code>里给<code>hook</code>传入的参数分别代表<code>to</code>、<code>from</code>、<code>next</code>，在队列执行完后执行传入的回调方法。这里执行过程代表了vue-router的守卫函数的执行函数。</p>\n<pre><code>export function runQueue (queue: Array&lt;?NavigationGuard&gt;, fn: Function, cb: Function) {\n  const step = index =&gt; {\n    if (index &gt;= queue.length) {\n      cb()\n    } else {\n      if (queue[index]) {\n        fn(queue[index], () =&gt; {\n          step(index + 1)\n        })\n      } else {\n        step(index + 1)\n      }\n    }\n  }\n  step(0)\n}</code></pre><p>综上所述，路由跳转的变化大概上已经解释完，当然这并不是完整的执行逻辑，只是路由跳转大概的过程差不多就是如此。</p>\n"},"26a0":function(e,n,t){"use strict";t.r(n),n["default"]="<p>__proto__和prototype是我们理解javascript最容易混淆的两个东西，但是理解了这两个对我们学习对象的继承和原型链有非常大的帮助。</p>\n<p>下面先说说这两个东西的概念：</p>\n<p>__proto__ ：指向一个对象的原型</p>\n<p>prototype ：函数特有的一个对象属性，并不是一个空对象，该对象里有一个constructor属性，指向当前的构造函数</p>\n<p>当我们使用new来执行一个函数时，实例会继承prototype对象上的属性，同时函数里的this将会指向调用这个构造函数的实例对象</p>\n<p>下面将使用代码说明</p>\n<pre><code>let father = function () {\n    this.a = 1\n}\n\nfather.prototype.b = 2\n\nlet fatherIns = new father()\n\nconsole.log(fatherIns) // {a: 1}\nconsole.log(fatherIns.b) // 2</code></pre><p>声明一个fatherIns的变量使用new关键词调用father，此时father函数里的this将会指向fatherIns，当我们打印这个对象时，fatherIns上并没有b这个属性，但是当我们尝试打印fatherIns.b时，之前我们在father.prototype上增加了一个<code>b = 2</code>的值，这时候js会尝试在这个对象原型链上寻找这个值，直到原型链最后为null，如果不存在这个属性则将会报出undefined的错误。</p>\n<p>为什么fatherIns.b会在原型链上被找到，这个时候就轮到__proto__出场</p>\n<p>__proto__是告诉js某个对象的原型对象指向谁，js就知道在原型链上下一步往哪去找</p>\n<pre><code>console.log(fatherIns.__proto__) // {b: 2}</code></pre><p>所以我们可以得出以下结果</p>\n<pre><code>fatherIns.__proto__ === father.prototype</code></pre><p>由此可知原型链就是这么来的，经典结论如下：</p>\n<p>JS里一切皆对象，对象的原型为null</p>\n<pre><code>fatherIns.__proto__.__proto__ === Object.prototype\n\nfatherIns.__proto__.__proto__.__proto__ === null</code></pre>"},3024:function(e,n){e.exports=function(e,n,t){var o=void 0===t;switch(n.length){case 0:return o?e():e.call(t);case 1:return o?e(n[0]):e.call(t,n[0]);case 2:return o?e(n[0],n[1]):e.call(t,n[0],n[1]);case 3:return o?e(n[0],n[1],n[2]):e.call(t,n[0],n[1],n[2]);case 4:return o?e(n[0],n[1],n[2],n[3]):e.call(t,n[0],n[1],n[2],n[3])}return e.apply(t,n)}},"3c11":function(e,n,t){"use strict";var o=t("63b6"),r=t("584a"),c=t("e53d"),i=t("f201"),d=t("cd78");o(o.P+o.R,"Promise",{finally:function(e){var n=i(this,r.Promise||c.Promise),t="function"==typeof e;return this.then(t?function(t){return d(n,e()).then(function(){return t})}:e,t?function(t){return d(n,e()).then(function(){throw t})}:e)}})},4178:function(e,n,t){var o,r,c,i=t("d864"),d=t("3024"),s=t("32fc"),a=t("1ec9"),l=t("e53d"),p=l.process,u=l.setImmediate,h=l.clearImmediate,f=l.MessageChannel,g=l.Dispatch,m=0,b={},v="onreadystatechange",x=function(){var e=+this;if(b.hasOwnProperty(e)){var n=b[e];delete b[e],n()}},w=function(e){x.call(e.data)};u&&h||(u=function(e){var n=[],t=1;while(arguments.length>t)n.push(arguments[t++]);return b[++m]=function(){d("function"==typeof e?e:Function(e),n)},o(m),m},h=function(e){delete b[e]},"process"==t("6b4c")(p)?o=function(e){p.nextTick(i(x,e,1))}:g&&g.now?o=function(e){g.now(i(x,e,1))}:f?(r=new f,c=r.port2,r.port1.onmessage=w,o=i(c.postMessage,c,1)):l.addEventListener&&"function"==typeof postMessage&&!l.importScripts?(o=function(e){l.postMessage(e+"","*")},l.addEventListener("message",w,!1)):o=v in a("script")?function(e){s.appendChild(a("script"))[v]=function(){s.removeChild(this),x.call(e)}}:function(e){setTimeout(i(x,e,1),0)}),e.exports={set:u,clear:h}},"43fc":function(e,n,t){"use strict";var o=t("63b6"),r=t("656e"),c=t("4439");o(o.S,"Promise",{try:function(e){var n=r.f(this),t=c(e);return(t.e?n.reject:n.resolve)(t.v),n.promise}})},4439:function(e,n){e.exports=function(e){try{return{e:!1,v:e()}}catch(n){return{e:!0,v:n}}}},"4c95":function(e,n,t){"use strict";var o=t("e53d"),r=t("584a"),c=t("d9f6"),i=t("8e60"),d=t("5168")("species");e.exports=function(e){var n="function"==typeof r[e]?r[e]:o[e];i&&n&&!n[d]&&c.f(n,d,{configurable:!0,get:function(){return this}})}},5756:function(e,n,t){},"5c95":function(e,n,t){var o=t("35e8");e.exports=function(e,n,t){for(var r in n)t&&e[r]?e[r]=n[r]:o(e,r,n[r]);return e}},6214:function(e,n,t){"use strict";t.r(n),n["default"]='<blockquote>\n<p>这一篇主要是讲解<code>vuex</code>的大概实现，以及一些细节的说明。</p>\n</blockquote>\n<h3 id="codevuexcode是如何实现的？"><code>vuex</code>是如何实现的？</h3>\n<p>先从<code>install</code>方法看，安装插件的方法实现比较简单，调用<code>applyMixin</code>，最后执行的是这段逻辑<code>Vue.mixin({ beforeCreate: vuexInit })</code>，实际上是在每个组件创建时混入<code>store</code>实例。所以我们可以在每个组件上获取到<code>store</code>实例上的数据。</p>\n<pre><code>if (version &gt;= 2) {\nVue.mixin({ beforeCreate: vuexInit })\n} else {\n// override init and inject vuex init procedure\n// for 1.x backwards compatibility.\nconst _init = Vue.prototype._init\nVue.prototype._init = function (options = {}) {\n  options.init = options.init\n    ? [vuexInit].concat(options.init)\n    : vuexInit\n  _init.call(this, options)\n}\n}\n\nfunction vuexInit () {\nconst options = this.$options\n// store injection\nif (options.store) {\n  this.$store = typeof options.store === &#39;function&#39;\n    ? options.store()\n    : options.store\n} else if (options.parent &amp;&amp; options.parent.$store) {\n  this.$store = options.parent.$store\n}\n}</code></pre><pre><code>function install (_Vue) {\n  if (Vue &amp;&amp; _Vue === Vue) {\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      console.error(\n        &#39;[vuex] already installed. Vue.use(Vuex) should be called only once.&#39;\n      )\n    }\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}</code></pre><p>接下来看看<code>store</code>这个类的代码：</p>\n<p>在这个类上暴露了<code>commit</code>和<code>dispatch</code>方法，并且绑定了调用上下文为<code>store</code>的实例。<code>dispatch</code>支持异步更新数据是因为它内部的实现就是使用了<code>promise</code>。</p>\n<pre><code>// bind commit and dispatch to self\nconst store = this\nconst { dispatch, commit } = this\nthis.dispatch = function boundDispatch (type, payload) {\n  return dispatch.call(store, type, payload)\n}\nthis.commit = function boundCommit (type, payload, options) {\n  return commit.call(store, type, payload, options)\n}</code></pre><p>下面两个方法是<code>vuex</code>的实现主要逻辑，<code>installModule</code>的具体逻辑不细说，从注释上我们可以知道，这是一个初始化整个<code>vuex</code>配置生成对象的方法。根据配置进行递归执行。</p>\n<pre><code>// init root module.\n// this also recursively registers all sub-modules\n// and collects all module getters inside this._wrappedGetters\ninstallModule(this, state, [], this._modules.root)\n\n// initialize the store vm, which is responsible for the reactivity\n// (also registers _wrappedGetters as computed properties)\nresetStoreVM(this, state)</code></pre><p><code>resetStoreVM</code>方法比较重要，下面是该方法的详细代码：</p>\n<ol>\n<li><code>vuex</code>中的<code>getter</code>实际上是使用<code>vue</code>计算属性实现的，<code>Object.defineProperty</code>里定义了<code>getter</code>的<code>get</code>方法。</li>\n<li><code>store._vm</code>实际就是<code>vuex</code>把<code>installModule</code>生成的对象改造成响应式的数据，通过一个新的<code>vue</code>实例。</li>\n<li>最后则是当我们重置<code>vuex</code>的响应数据，需要销毁旧的实例，回收内存。</li>\n</ol>\n<pre><code>function resetStoreVM (store, state, hot) {\n  const oldVm = store._vm\n\n  // bind store public getters\n  store.getters = {}\n  const wrappedGetters = store._wrappedGetters\n  const computed = {}\n  forEachValue(wrappedGetters, (fn, key) =&gt; {\n    // use computed to leverage its lazy-caching mechanism\n    // direct inline function use will lead to closure preserving oldVm.\n    // using partial to return function with only arguments preserved in closure enviroment.\n    computed[key] = partial(fn, store)\n    Object.defineProperty(store.getters, key, {\n      get: () =&gt; store._vm[key],\n      enumerable: true // for local getters\n    })\n  })\n\n  // use a Vue instance to store the state tree\n  // suppress warnings just in case the user has added\n  // some funky global mixins\n  const silent = Vue.config.silent\n  Vue.config.silent = true\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed\n  })\n  Vue.config.silent = silent\n\n  // enable strict mode for new vm\n  if (store.strict) {\n    enableStrictMode(store)\n  }\n\n  if (oldVm) {\n    if (hot) {\n      // dispatch changes in all subscribed watchers\n      // to force getter re-evaluation for hot reloading.\n      store._withCommit(() =&gt; {\n        oldVm._data.$$state = null\n      })\n    }\n    Vue.nextTick(() =&gt; oldVm.$destroy())\n  }\n}</code></pre><h3 id="修改codevuexcode的数据是如何响应到视图？">修改<code>vuex</code>的数据是如何响应到视图？</h3>\n<ol>\n<li><code>vuex</code>的<code>state</code>和<code>getter</code>实际上就是对应的<code>store._vm</code>（<code>vue</code>实例）中<code>data</code>和<code>computed</code>，因此<code>getter</code>所依赖的<code>state</code>最后是通过<code>watcher</code>管理的。</li>\n<li>当我们在组件中使用<code>vuex</code>，<code>vuex</code>生成的实例对象在<code>vue</code>实例化过程中被改造成响应式的数据，当我们有多个页面组件使用了<code>vuex</code>的数据，其实也是通过<code>watcher</code>管理，因此当我们使用<code>commit</code>或<code>dispatch</code>修改数据，最后触发了<code>setter</code>去通知所有订阅者（<code>watcher</code>）更新。</li>\n</ol>\n<h3 id="总结">总结</h3>\n<p><code>vuex</code>的设计其实并不复杂，简单的来讲，就是一个对象，通过内部的方法管理内部的属性和读取内部的属性。</p>\n<p>而实现的过程，则是通过一系列方法把我们的配置生成一个<code>root</code>对象，然后利用<code>vue</code>实现内部数据的响应与依赖管理。而这里比较核心的部分则是当数据发生变化时，如何响应到对应的视图部分以及<code>getter</code>的依赖管理，这些逻辑的实现最后都是通过<code>watcher</code>。</p>\n'},"63b7":function(e,n,t){"use strict";t.r(n),n["default"]='<blockquote>\n<p>这一篇主要是讲解一下vue里mvvm的原理，以及如何理解vue实现mvvm。</p>\n</blockquote>\n<p>稍微有去了解过vue是如何双向绑定的我们都很容易知道vue是通过<code>Object.defineProperty</code>劫持<code>data</code>属性的<code>setter</code>和<code>getter</code>，但是这仅仅只是实现的一部分，在这个实现里我们还要理解<code>dep</code>（订阅中心）和<code>watcher</code>（订阅者）的概念。</p>\n<h3 id="codedepcode订阅中心"><code>dep</code>—订阅中心</h3>\n<p><code>dep</code>代码在<code>./src/core/observer/dep.js</code>文件里，下面简单讲解一下：</p>\n<ol>\n<li><code>dep</code>的定义参考了观察者设计模式，每一个<code>dep</code>有自己的唯一标识<code>id</code>和订阅者列表<code>subs</code>。</li>\n<li><code>addSub</code>和<code>removeSub</code>用来管理订阅者列表<code>subs</code>。</li>\n<li><code>depend</code>用来收集<code>watcher</code>（订阅者）。</li>\n<li><code>notify</code>用来通知<code>watcher</code>（订阅者）执行更新。</li>\n<li><code>Dep.target</code>刚开始看是比较难理解的一个概念，<code>Dep.target</code>其实是调用当前<code>dep</code>对应属性的<code>watcher</code>。举个例子：假如<code>data</code>有个属性<code>name</code>，那么当<code>data.name</code>的<code>getter</code>被触发时，我们需要知道是谁在调用这个<code>data.name</code>的<code>getter</code>，这就是<code>Dep.target</code>。</li>\n</ol>\n<pre><code>export default class Dep {\n  static target: ?Watcher;\n  id: number;\n  subs: Array&lt;Watcher&gt;;\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n\n  removeSub (sub: Watcher) {\n    remove(this.subs, sub)\n  }\n\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n\n  notify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !config.async) {\n      // subs aren&#39;t sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort((a, b) =&gt; a.id - b.id)\n    }\n    for (let i = 0, l = subs.length; i &lt; l; i++) {\n      subs[i].update()\n    }\n  }\n}\n// The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\nDep.target = null\nconst targetStack = []\n\nexport function pushTarget (target: ?Watcher) {\n  targetStack.push(target)\n  Dep.target = target\n}\n\nexport function popTarget () {\n  targetStack.pop()\n  Dep.target = targetStack[targetStack.length - 1]\n}\n</code></pre><h3 id="codewatchercode订阅者"><code>watcher</code>—订阅者</h3>\n<p><code>watcher</code>代码在<code>./src/core/observer/watcher.js</code>文件里，关于<code>watcher</code>的选项配置就不细说了，在这里我们只需要重点关注其中的<code>get</code>\n、<code>update</code>、<code>run</code>、<code>evaluate</code>这几个方法。</p>\n<p>这几个方法的作用稍后解释，现在我们要先理解怎样才会产生一个<code>watcher</code>。在vue里面，有三种类型的<code>watcher</code>：</p>\n<ol>\n<li>每一个组件的实例都是一个<code>watcher</code></li>\n<li>在组件的<code>watch</code>选项中声明的<code>watcher</code></li>\n<li>计算属性所使用的依赖值会给对应的依赖值添加一个<code>watcher</code></li>\n</ol>\n<p>讲完<code>watcher</code>的来源后我们再来看这几个方法的讲解：</p>\n<ol>\n<li>先从<code>update</code>讲起，当某个响应属性发生变化时触发<code>setter</code>后，执行<code>dep.notify</code>通知每个<code>watcher</code>执行<code>update</code>，代码比较简单，三个逻辑分支，判断<code>this.lazy</code>，这是应用于<font color=red>计算属性</font>时会触发的逻辑分支，<code>this.sync\n</code>则用于判断同步执行<code>watcher</code>的回调，否则推入<code>queueWatcher</code>后续执行。</li>\n<li><code>run</code>和<code>evaluate</code>都是会调用<code>get</code>方法，只是<code>run</code>方法是用于组件实例的<code>watcher</code>和<code>watch</code>选项中声明的<code>watcher</code>，<code>watch</code>选项中声明的<code>watcher</code>的<code>this.user</code>为<code>true</code>，在<code>run</code>方法中的<code>this.cb.call(this.vm, value, oldValue)</code>这段代码则是我们<code>watch</code>选项中触发的回调。至于<code>evaluate</code>方法则更加简单了，调用<code>get</code>方法然后设置<code>this.dirty</code>为<code>false</code>则是为了后续其他地方使用这个计算属性的时候不需要重新计算，这也是<font color=red>计算属性缓存</font>的一部分逻辑。</li>\n<li>接下来讲讲<code>get</code>方法，<code>pushTarget(this)</code>这段则是设置<code>Dep.target</code>为当前<code>watcher</code>实例，其实就是告诉<code>dep</code>是谁在获取属性。<code>value = this.getter.call(vm, vm)</code>则是获取当前值，在这里三种类型的<code>watcher</code>的<code>getter</code>是不一样的。</li>\n<li>最后提一下，计算属性的值一般是在组件实例的<code>watcher</code>执行<code>getter</code>的过程中执行计算的。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>watcher类型</th>\n<th>getter</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>组件实例</td>\n<td>render函数</td>\n</tr>\n<tr>\n<td>watch</td>\n<td>执行parsePath方法生成的函数</td>\n</tr>\n<tr>\n<td>计算属性</td>\n<td>执行createComputedGetter方法生成的函数</td>\n</tr>\n</tbody></table>\n<pre><code>export default class Watcher {\n  vm: Component;\n  expression: string;\n  cb: Function;\n  id: number;\n  deep: boolean;\n  user: boolean;\n  lazy: boolean;\n  sync: boolean;\n  dirty: boolean;\n  active: boolean;\n  deps: Array&lt;Dep&gt;;\n  newDeps: Array&lt;Dep&gt;;\n  depIds: SimpleSet;\n  newDepIds: SimpleSet;\n  before: ?Function;\n  getter: Function;\n  value: any;\n\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: ?Object,\n    isRenderWatcher?: boolean\n  ) {\n    this.vm = vm\n    if (isRenderWatcher) {\n      vm._watcher = this\n    }\n    vm._watchers.push(this)\n    // options\n    if (options) {\n      this.deep = !!options.deep\n      this.user = !!options.user\n      this.lazy = !!options.lazy\n      this.sync = !!options.sync\n      this.before = options.before\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false\n    }\n    this.cb = cb\n    this.id = ++uid // uid for batching\n    this.active = true\n    this.dirty = this.lazy // for lazy watchers\n    this.deps = []\n    this.newDeps = []\n    this.depIds = new Set()\n    this.newDepIds = new Set()\n    this.expression = process.env.NODE_ENV !== &#39;production&#39;\n      ? expOrFn.toString()\n      : &#39;&#39;\n    // parse expression for getter\n    if (typeof expOrFn === &#39;function&#39;) {\n      this.getter = expOrFn\n    } else {\n      this.getter = parsePath(expOrFn)\n      if (!this.getter) {\n        this.getter = noop\n        process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(\n          `Failed watching path: &quot;${expOrFn}&quot; ` +\n          &#39;Watcher only accepts simple dot-delimited paths. &#39; +\n          &#39;For full control, use a function instead.&#39;,\n          vm\n        )\n      }\n    }\n    this.value = this.lazy\n      ? undefined\n      : this.get()\n  }\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  get () {\n    pushTarget(this)\n    let value\n    const vm = this.vm\n    try {\n      value = this.getter.call(vm, vm)\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, `getter for watcher &quot;${this.expression}&quot;`)\n      } else {\n        throw e\n      }\n    } finally {\n      // &quot;touch&quot; every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value)\n      }\n      popTarget()\n      this.cleanupDeps()\n    }\n    return value\n  }\n\n  /**\n   * Add a dependency to this directive.\n   */\n  addDep (dep: Dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\n\n  /**\n   * Clean up for dependency collection.\n   */\n  cleanupDeps () {\n    let i = this.deps.length\n    while (i--) {\n      const dep = this.deps[i]\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this)\n      }\n    }\n    let tmp = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n  }\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n  update () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true\n    } else if (this.sync) {\n      this.run()\n    } else {\n      queueWatcher(this)\n    }\n  }\n\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n  run () {\n    if (this.active) {\n      const value = this.get()\n      if (\n        value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        isObject(value) ||\n        this.deep\n      ) {\n        // set new value\n        const oldValue = this.value\n        this.value = value\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue)\n          } catch (e) {\n            handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`)\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue)\n        }\n      }\n    }\n  }\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n  evaluate () {\n    this.value = this.get()\n    this.dirty = false\n  }\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n  depend () {\n    let i = this.deps.length\n    while (i--) {\n      this.deps[i].depend()\n    }\n  }\n\n  /**\n   * Remove self from all dependencies&#39; subscriber list.\n   */\n  teardown () {\n    if (this.active) {\n      // remove self from vm&#39;s watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this)\n      }\n      let i = this.deps.length\n      while (i--) {\n        this.deps[i].removeSub(this)\n      }\n      this.active = false\n    }\n  }\n}\n</code></pre><h3 id="总结">总结</h3>\n<p>其实学习vue的mvvm，重点在于<code>dep</code>和<code>watcher</code>的理解，要明白这两个类的实例在双向绑定的过程中扮演的是一个什么样角色，单纯从代码上可能不太容易理解这样设计的意图，但是如果能有一个比较具象化的东西来对应，相信对你的理解会有非常大的帮助。</p>\n'},"656e":function(e,n,t){"use strict";var o=t("79aa");function r(e){var n,t;this.promise=new e(function(e,o){if(void 0!==n||void 0!==t)throw TypeError("Bad Promise constructor");n=e,t=o}),this.resolve=o(n),this.reject=o(t)}e.exports.f=function(e){return new r(e)}},"696e":function(e,n,t){t("c207"),t("1654"),t("6c1c"),t("24c5"),t("3c11"),t("43fc"),e.exports=t("584a").Promise},"69b0":function(e,n,t){"use strict";t.r(n),n["default"]='<blockquote>\n<p>跨域可以说是前端开发中很常见的一个问题了，虽然网上已经有很多类似的文章，不过本着记录自己的学习总结想法，还是要自己写一遍文章记录一下所学知识。</p>\n</blockquote>\n<h2 id="为什么会有跨域？">为什么会有跨域？</h2>\n<p>跨域的问题产生是因为浏览器的<strong>同源策略</strong>所导致的。同源策略的出发点是出于浏览器的安全所考虑的，如果每个人都可以随意访问其他站点的文件数据，将会产生非常严重的安全问题。</p>\n<p>那怎么样才算是跨域呢？在浏览器里只要满足以下条件任一个就算跨域：</p>\n<blockquote>\n<ol>\n<li>请求协议不同 <br/>\n例：http和https</li>\n<li>域名不同<br/>\n例：xxx.com和mmm.com</li>\n<li>端口不同<br/>\n例：xxx.com和xxx.com:81\n</li>\n</ol>\n</blockquote>\n<h2 id="跨域的几种解决方法">跨域的几种解决方法</h2>\n<h3 id="1-jsonp">1. JSONP</h3>\n<p>JSONP实现跨域的原理是动态创建script标签，src是具有跨域访问文件的能力，创建指定的地址和调用特定的回调方法获取数据，JSONP只支持get方法。</p>\n<h3 id="2cors">2.CORS</h3>\n<p>CORS（跨域资源共享）实现跨域的原理是在http请求头中加上指定的标记来告诉浏览器是否允许加载跨域的资源，也是现在主流的跨越解决方案。</p>\n<h3 id="3iframe--locationhash">3.iframe + location.hash</h3>\n<p>iframe+location.hash实现跨域是使用iframe加载资源，然后在iframe中修改父窗口的location.hash，因为location.hash的信息会展示在url上，所以url的长度限制了我们传输信息内容的长度。</p>\n<h3 id="4-iframe--windowname">4. iframe + window.name</h3>\n<p>iframe+location.hash实现跨域是使用iframe加载资源，然后在iframe窗口加载的内容修改window.name的值，使用了window.name的特性，在当前窗口页所有加载的页面共享一个window.name，但是window.name的容量限制为不超过2m。</p>\n<h3 id="5-iframe--documentdomain">5. iframe + document.domain</h3>\n<p>如果两个页面的主域名相同，但是子域名不同，可以修改document.domain为同一个域名，实现父子域名的跨域通信，只限制主域名相同的情况下。（不算严格意义上的跨域）</p>\n<h3 id="6-postmessage">6. postMessage</h3>\n<p>postMessage是html5标准的新特性，使用该api可以实现多种场景的跨域通信，但是在一些比较老旧的浏览器可能不支持此方法。</p>\n<h3 id="7反向代理">7.反向代理</h3>\n<p>使用nginx或者nodejs中间件通过反向代理实现跨域访问。</p>\n<h3 id="8websocket协议">8.WebSocket协议</h3>\n<p>WebScoket协议支持跨域通信。</p>\n<h2 id="总结">总结</h2>\n<p>综合以上几种的跨域解决方案来看，解决跨域大都是在服务器端，不管是从安全性还是实用性上来说。使用前端手段解决跨域的方案或多或少都有点缺陷，前端解决跨域的重点也是在围绕src的能力来展开，不管是iframe还是动态创建script。</p>\n'},7456:function(e,n,t){"use strict";var o=t("5756"),r=t.n(o);r.a},"78b0":function(e,n,t){},"795b":function(e,n,t){e.exports=t("696e")},"83db":function(e,n,t){"use strict";t.r(n),n["default"]='<h2 id="codeinlinecode元素、codeinline-blockcode元素、codeblockcode元素的区别"><code>inline</code>元素、<code>inline-block</code>元素、<code>block</code>元素的区别</h2>\n<ol>\n<li><code>inline</code>元素根据宽度横向排列，<code>block</code>元素默认独占一行；</li>\n<li><code>inline</code>元素无法设置上下外边距(<code>margin</code>)、<code>width</code>、<code>height</code>，<code>block</code>元素可以设置四个方向的外边距和元素的<code>width</code>、<code>height</code>；</li>\n<li><code>inline-block</code>元素则融合了<code>inline</code>元素和<code>block</code>元素，可以像<code>inline</code>元素横向排列以及像<code>block</code>元素设置四个方向的外边距以及<code>width</code>、<code>height</code>；</li>\n</ol>\n<p>效果图如下：</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/8/10/16c7a14e82ef9a8e?w=740&h=758&f=png&s=57903" alt=""></p>\n<p>代码如下：</p>\n<pre><code>&lt;div&gt;\n    &lt;div style=&quot;display: block;width: 100px;height: 100px;background-color: red;margin: 10px;padding: 10px;border: 1px solid grey;&quot;&gt;block&lt;/div&gt;\n    &lt;div style=&quot;display: inline-block;width: 100px;height: 100px;background-color: blue;margin: 10px;padding: 10px;border: 1px solid grey;&quot;&gt;inline-block&lt;/div&gt;\n    &lt;div style=&quot;display: inline;width: 100px;height: 100px;background-color: yellow;margin: 10px;padding: 10px;border: 1px solid grey;&quot;&gt;inline&lt;/div&gt;\n&lt;/div&gt;</code></pre><p>我们给<code>inline</code>元素设置四个方向外边距，只有左右的外边距才显示出了效果。</p>\n<h2 id="codeflex-growcode容易忽略的坑"><code>flex-grow</code>容易忽略的坑</h2>\n<p>我们先看看<code>flex-grow</code>的定义：</p>\n<p><code>flex-grow</code>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>\n<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>\n<p>根据定义我们可以得知，当在<code>flex</code>容器内给容器内的项目设置不同的<code>flex-grow</code>，可以根据比例设置项目的空间；</p>\n<p>先看第一个例子：</p>\n<p><code>flex</code>容器宽度为<code>780px</code>，容器内有三个项目，第一个项目固定宽度<code>480px</code>，剩下的两个项目根据比例分配。</p>\n<p>效果图如下：</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/8/10/16c7a23650a45341?w=1570&h=522&f=jpeg&s=48236" alt=""></p>\n<p>代码如下：</p>\n<pre><code>&lt;div style=&quot;display: flex;color: grey;width: 780px;&quot;&gt;\n    &lt;div style=&quot;height:100px;flex-basis: 480px;background-color: red;&quot;&gt;width480px&lt;/div&gt;\n    &lt;div style=&quot;height:100px;flex-grow: 2;background-color: blue;&quot;&gt;flex-grow: 2&lt;/div&gt;\n    &lt;div style=&quot;height:100px;flex-grow: 1;background-color: yellow;&quot;&gt;flex-grow: 1&lt;/div&gt;\n&lt;/div&gt;</code></pre><p>从效果图得知，除了固定宽度的项目，另外两个项目的宽度并未按照我们所想的那样分配。</p>\n<p>重新去看定义，分配“_剩余空间_”似乎并不是我们理解的那样，具体这个“_剩余空间_”是如何计算我并未具体去研究，在这里先说说如何解决这个问题。</p>\n<ol>\n<li>当剩余两个项目内不存在内容的时候，分配的空间就是正确的；\n效果图如下：\n<img src="https://user-gold-cdn.xitu.io/2019/8/10/16c7a2b825c7ad9b?w=1602&h=422&f=jpeg&s=30203" alt="">\n代码如下：<pre><code>&lt;div style=&quot;display: flex;color: grey;width: 780px;&quot;&gt;\n &lt;div style=&quot;height:100px;flex-basis: 480px;background-color: red;&quot;&gt;width480px&lt;/div&gt;\n &lt;div style=&quot;height:100px;flex-grow: 2;background-color: blue;&quot;&gt;&lt;/div&gt;\n &lt;div style=&quot;height:100px;flex-grow: 1;background-color: yellow;&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;</code></pre></li>\n</ol>\n<p>当我们把除了固定宽度外的项目的内容去掉，分配的空间比例就是正确的，但是这种解决方法肯定不是我们想要的。</p>\n<ol start="2">\n<li>给剩余两个项目设置<code>flex-basic: 0;</code></li>\n</ol>\n<p>效果图如下：\n<img src="https://user-gold-cdn.xitu.io/2019/8/10/16c7a2e66c7eb215?w=1604&h=566&f=jpeg&s=51175" alt="">\n代码如下：</p>\n<pre><code>&lt;div style=&quot;display: flex;color: grey;width: 780px;&quot;&gt;\n    &lt;div style=&quot;height:100px;flex-basis: 480px;background-color: red;&quot;&gt;width480px&lt;/div&gt;\n    &lt;div style=&quot;height:100px;flex-grow: 2;background-color: blue;flex-basis: 0;&quot;&gt;flex-grow: 2&lt;/div&gt;\n    &lt;div style=&quot;height:100px;flex-grow: 1;background-color: yellow;flex-basis: 0;&quot;&gt;flex-grow: 1&lt;/div&gt;\n&lt;/div&gt;</code></pre><p>在这里当我们给除了固定宽度外的项目加上<code>flex-basic: 0</code>后，分配的空间就是我们所期望的那样了。</p>\n<p>如果我们需要使用<code>flex-grow</code>来分配<code>flex</code>容器内的项目，一定要注意设置<code>flex-basic</code>。因为这里的“_剩余空间_”和<code>flex-basic</code>相关。</p>\n<p>下面我们看看<code>flex-basic</code>的定义：</p>\n<p><code>flex-basic</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>\n<p>当我们一个<code>flex</code>容器内的项目同时存在<code>flex-basic</code>和<code>flex-grow</code>，这个项目的宽度为<code>flex-basic</code>的值加上<code>flex-grow</code>所分配到的空间。</p>\n<p>还是以上面的代码举例，假如我们给两个项目的<code>flex-basic</code>设置值为<code>30px</code>和<code>60px</code></p>\n<p>则剩余两个容器的宽度分别为：</p>\n<p><code>width1 = ((780 - 480 - 30 - 60) * 2 / 3) + 30 = 170</code></p>\n<p><code>width2 = ((780 - 480 - 30 - 60) * 1 / 3) + 60 = 130</code></p>\n<p>效果图如下：</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/8/10/16c7a5a01b1f48fe?w=1610&h=494&f=jpeg&s=54951" alt="">\n代码如下：</p>\n<pre><code>&lt;div style=&quot;display: flex;color: grey;width: 780px;&quot;&gt;\n    &lt;div style=&quot;height:100px;flex-basis: 480px;background-color: red;&quot;&gt;width480px&lt;/div&gt;\n    &lt;div style=&quot;height:100px;flex-grow: 2;background-color: blue;flex-basis: 30px;&quot;&gt;flex-grow: 2&lt;/div&gt;\n    &lt;div style=&quot;height:100px;flex-grow: 1;background-color: yellow;flex-basis: 60px;&quot;&gt;flex-grow: 1&lt;/div&gt;\n&lt;/div&gt;</code></pre><h2 id="多个codeclasscode样式的时候如何取值？">多个<code>class</code>样式的时候如何取值？</h2>\n<p>当某个<code>div</code>元素上<code>class</code>的值为<code>a b c</code>的时候，最后的样式是如何计算的？</p>\n<pre><code>&lt;div class=&quot;a b c&quot;&gt;&lt;/div&gt;</code></pre><p>这个问题我们讨论的前提是同样的样式属性；</p>\n<ol>\n<li>不考虑权重的情况下，<code>a b c</code>最终决定元素的样式为加载的顺序，哪个<code>class</code>最后加载则显示为哪个<code>class</code>的效果，和书写顺序无关。</li>\n</ol>\n<ul>\n<li>当<code>a b c</code>都在同一个文件的情况下，哪个定义在最后，则以最后的为准；</li>\n</ul>\n<pre><code>.c {\n    background-color: green;\n}\n\n.b {\n    background-color: yellow;\n}\n\n.a {\n    background-color: red;\n}</code></pre><ul>\n<li>当<code>a b c</code>在不同的文件的情况下，哪个文件最后加载，则以最后的为准；</li>\n</ul>\n<pre><code>    &lt;link rel=&quot;stylesheet&quot; href=&quot;cssC.css&quot;&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;cssB.css&quot;&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;cssA.css&quot;&gt;</code></pre><ol start="2">\n<li><p>如果某个<code>class</code>中设置了<code>!important</code>，则直接以<code>!important</code>的为准。</p>\n</li>\n<li><p>其他时候则按照选择器的权重来计算样式。</p>\n</li>\n</ol>\n'},"8bff":function(e,n,t){"use strict";t.r(n),n["default"]='<h2 id="node-assert-api学习">node Assert api学习</h2>\n<ol>\n<li>assert.strictEqual() / assert.notStrictEqual() 判断期望值与实际值是否相等或不相等</li>\n<li>assert.deepStrictEqual() / assert.notDeepStrictEqual() 判断对象是否完全相等或不相等（深度遍历对象的可枚举属性，且递归对比子对象的可枚举属性）</li>\n<li>assert.throws() / assert.doesNotThrow() 判断执行的函数是否抛出错误</li>\n<li>assert.rejects() / assert.doesNotReject() 判断执行异步函数是否返回拒绝状态的Promise</li>\n<li>assert.ok() 判断是否为真值</li>\n<li>assert.ifError() 判断实际值是否为undefined 或 null</li>\n<li>assert.fail() 默认抛出AssertionError提供的错误提示，如果是Error实例，则抛出实例错误提示</li>\n</ol>\n<p>以上为个人对Assert类的api理解，第三方断言库的语法基本和此接近，用法上可能更方便，语义化更好。</p>\n<h2 id="mocha--should">mocha + should</h2>\n<p><a href="https://mochajs.org/">mocha</a>单元测试框架</p>\n<p><a href="http://shouldjs.github.io/">should</a>BDD风格第三方断言库，mocha同时也支持其他第三方断言库，选择哪看个人喜好</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/3/15/16981e8c40ebddc7?w=1920&h=656&f=png&s=134977" alt=""></p>\n<p>根据mocha的Github文档说明安装mocha，</p>\n<pre><code>npm install -g mocha</code></pre><p>增加一个名为mocha.opts的配置文件，文件内容为</p>\n<pre><code>--require should</code></pre><p>可直接默认添加依赖，无需手动required</p>\n<p><em>提示：使用最新版本的mocha在package.json文件所在目录下执行mocha命令不会加载opts文件，降低版本可解决这个问题</em></p>\n<p>以下代码为should文档使用的例子</p>\n<p>引入should依赖后自动绑定should的api到Object.prototype原型上，如果是Object.create(null)创建的则使用should(params)来使用should的api，具体api参考should文档</p>\n<pre><code>var should = require(&#39;should&#39;);\n\nvar user = {\n    name: &#39;tj&#39;\n  , pets: [&#39;tobi&#39;, &#39;loki&#39;, &#39;jane&#39;, &#39;bandit&#39;]\n};\n\nuser.should.have.property(&#39;name&#39;, &#39;tj&#39;);\nuser.should.have.property(&#39;pets&#39;).with.lengthOf(4);\n\n// If the object was created with Object.create(null)\n// then it doesn&#39;t inherit `Object.prototype`, so it will not have `.should` getter\n// so you can do:\nshould(user).have.property(&#39;name&#39;, &#39;tj&#39;);\n\n// also you can test in that way for null&#39;s\nshould(null).not.be.ok();\n\nsomeAsyncTask(foo, function(err, result){\n  should.not.exist(err);\n  should.exist(result);\n  result.bar.should.equal(foo);\n});</code></pre><p>下面代码为一个测试用例，测试一个大数相加的函数，输入与输出是否一致:</p>\n<pre><code>let add = require(&#39;../lib/add&#39;)\n\ndescribe(&#39;大数相加add方法&#39;, function () {\n    it(&#39;字符串&quot;42329&quot;加上字符串&quot;21532&quot;等于&quot;63861&quot;&#39;, function () {\n        add(&#39;42329&#39;, &#39;21532&#39;)\n            .should.equal(&#39;63861&#39;)\n    })\n\n    it(&#39;&quot;843529812342341234&quot;加上&quot;236124361425345435&quot;等于&quot;1079654173767686669&quot;&#39;, function () {\n        add(&#39;843529812342341234&#39;, &#39;236124361425345435&#39;)\n            .should.equal(&#39;1079654173767686669&#39;)\n    })\n})</code></pre><p>describe()定义了一组测试用例，describe()内可重复嵌套describe()，第一个参数为测试用例命名，第二个参数为执行的函数</p>\n<p>在项目目录下运行mocha命令执行测试\n<img src="https://user-gold-cdn.xitu.io/2019/3/15/16981fc41dbbb857?w=1278&h=340&f=png&s=34723" alt="">\n大数相加的函数输出值与我们输入的期望值则通过测试。</p>\n<h2 id="karma--mocha--travis-ci">Karma + mocha + travis-CI</h2>\n<p><a href="https://karma-runner.github.io/1.0/index.html">Krama</a> 一个基于Node.js的JavaScript测试执行过程管理工具</p>\n<p><a href="https://www.travis-ci.org/">travis-CI</a> 持续集成构建项目</p>\n<p>首先根据krama Github文档安装</p>\n<pre><code>npm install -g krama</code></pre><p>安装完成后在我们的项目中执行</p>\n<pre><code>karma init</code></pre><p>执行命令后按照官网文档说明初始化部分配置</p>\n<pre><code>$ karma init\n\n// 选择使用的测试框架\nWhich testing framework do you want to use?\nPress tab to list possible options. Enter to move to the next question.\n&gt; jasmine\n\n// 是否使用require.js\nDo you want to use Require.js?\nThis will add Require.js plugin.\nPress tab to list possible options. Enter to move to the next question.\n&gt; no\n\n// 是否自动绑定浏览器\nDo you want to capture a browser automatically?\nPress tab to list possible options. Enter empty string to move to the next question.\n&gt; Chrome\n&gt; Firefox\n&gt;\n\n// 输入你的项目依赖源和测试的文件，一个一个输入，最后生成一个数组\nWhat is the location of your source and test files?\nYou can use glob patterns, eg. &quot;js/*.js&quot; or &quot;test/**/*Spec.js&quot;.\nPress Enter to move to the next question.\n&gt; *.js\n&gt; test/**/*.js\n&gt;\n\n// 排除部分文件\nShould any of the files included by the previous patterns be excluded?\nYou can use glob patterns, eg. &quot;**/*.swp&quot;.\nPress Enter to move to the next question.\n&gt;\n\n// 监听文件并且当文件改变时候执行测试\nDo you want Karma to watch all the files and run the tests on change?\nPress tab to list possible options.\n&gt; yes\n</code></pre><p>最后本人项目生成的karma配置文件如下</p>\n<pre><code>// Karma configuration\n// Generated on Tue Mar 12 2019 21:15:08 GMT+0800 (China Standard Time)\n\nmodule.exports = function (config) {\n    config.set({\n\n        // base path that will be used to resolve all patterns (eg. files, exclude)\n        basePath: &#39;&#39;,\n\n\n        // frameworks to use\n        // available frameworks: https://npmjs.org/browse/keyword/karma-adapter\n        frameworks: [&#39;mocha&#39;],\n\n\n        // list of files / patterns to load in the browser\n        files: [\n            &#39;https://cdn.bootcss.com/jquery/2.2.4/jquery.js&#39;,\n            &#39;node_modules/should/should.js&#39;,\n            &#39;test/**.js&#39;\n        ],\n\n\n        // list of files to exclude\n        exclude: [],\n\n\n        // preprocess matching files before serving them to the browser\n        // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor\n        preprocessors: {},\n\n\n        // test results reporter to use\n        // possible values: &#39;dots&#39;, &#39;progress&#39;\n        // available reporters: https://npmjs.org/browse/keyword/karma-reporter\n        reporters: [&#39;progress&#39;],\n\n\n        // web server port\n        port: 9876,\n\n\n        // enable / disable colors in the output (reporters and logs)\n        colors: true,\n\n\n        // level of logging\n        // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG\n        logLevel: config.LOG_INFO,\n\n\n        // enable / disable watching file and executing tests whenever any file changes\n        autoWatch: true,\n\n\n        // start these browsers\n        // available browser launchers: https://npmjs.org/browse/keyword/karma-launcher\n        browsers: [&#39;Chrome&#39;],\n\n        // Continuous Integration mode\n        // if true, Karma captures browsers, runs the tests and exits\n        singleRun: true,\n\n        // Concurrency level\n        // how many browser should be started simultaneous\n        concurrency: Infinity\n    })\n}\n</code></pre><p>把我们的项目接入travis-CI持续集成，首先登陆travis-CI网站<a href="https://www.travis-ci.org/">https://www.travis-ci.org/</a></p>\n<p><em>提示：需要有自己的github账号，并且以github账号授权登陆travis-ci网站</em></p>\n<p>登陆后可以看到自己github上所有项目仓库，选择你需要持续集成的项目仓库</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/3/16/1698468b9abfcecc?w=1382&h=654&f=png&s=95231" alt="">\n按照文档说明要在项目目录下新增一个.travis.yml文件，配置文件内容参考文档<a href="https://docs.travis-ci.com/user/languages/javascript-with-nodejs/">https://docs.travis-ci.com/user/languages/javascript-with-nodejs/</a></p>\n<p>下面是简单的配置文件说明</p>\n<pre><code>language: node_js\nnode_js:\n  - &quot;lts/*&quot;\nbefore_script:\n  - export DISPLAY=:99.0\n  - sh -e /etc/init.d/xvfb start</code></pre><p>language: 定义我们测试的语言</p>\n<p>node_js: 定义node的版本，可以指定某个特定的版本\n<img src="https://user-gold-cdn.xitu.io/2019/3/16/169845b68d5ea417?w=560&h=302&f=png&s=23934" alt="">\n按照文档说明，travis-CI执行测试默认执行npm install安装依赖包，安装完依赖后默认执行npm test命令执行测试任务。</p>\n<p>before_script:在script配置命令前执行</p>\n<p>根据karma官网文档说明接入travis-CI的配置里说明<a href="http://karma-runner.github.io/1.0/plus/travis.html">http://karma-runner.github.io/1.0/plus/travis.html</a></p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/3/16/169846092e4584de?w=2042&h=636&f=png&s=108274" alt=""></p>\n<p>新增.travis.yml文件后并上传到github项目仓库中，在travis-ci网站中打开开关，travis-ci检测到配置文件会自动执行测试命令</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/3/16/169846e9815e2c76?w=3336&h=766&f=png&s=180559" alt=""></p>\n<p>在job log标签页中可以看到执行任务的日志</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/3/16/169847192a1e0f81?w=2728&h=1766&f=png&s=430910" alt=""></p>\n<p>根据任务日志可以看到我们的测试任务执行情况，4个测试用例均通过测试。</p>\n<p>在集成travis-ci到项目中遇到了不少坑，翻了文档看了很多配置，一开始以为是chrome-launch的问题，在before_script中手动安装也是报错；另外一开始是看到文档里是对firefox配置，以为这是专门针对firefox的配置，后来照着karma接入travis-ci的文档配置尝试一下，居然成功了，这结果来得太意外。</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/3/16/1698476b924555b9?w=2042&h=636&f=png&s=108274" alt=""></p>\n<p>另外在karma.conf的文件中，singleRun的配置也需要配置成true，不然travis-ci任务会一直执行。</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/3/16/169847b76a941a40?w=497&h=73&f=png&s=9990" alt=""></p>\n<p>以上所述为第一次探索自动化测试的过程，确实学习到了很多东西，但是很多高级的用法并不太了解，也有不足的地方没有接入到真实项目中配合使用。</p>\n'},9346:function(e,n,t){"use strict";t.r(n),n["default"]='<p>js在比较运算过程中经常会发生隐式转换，常常会给人意料外的结果，而隐式转换在面试过程中又经常会被考到，所以打算好好整理一下隐式转换这个知识点，本文算是个人对隐式转换的学习梳理。</p>\n<h2 id="1tostring和valueof">1.toString和valueOf</h2>\n<p>toString：toString()函数的作用是返回object的字符串表示</p>\n<ul>\n<li>Array 返回数组元素的字符串，默认以逗号链接。</li>\n<li>Boolean 布尔值的字符串值</li>\n<li>Date 日期UTC标准格式</li>\n<li>Function 函数的字符串值</li>\n<li>Number 数字值的字符串值</li>\n<li>Object [Object Object]</li>\n<li>String 字符串值</li>\n<li>Reg 正则的字符串值</li>\n</ul>\n<p>如下代码演示（以下演示情况是toString方法没有被重写）</p>\n<pre><code>let num = 1\nlet str = &#39;a&#39;\nlet bool = true\nlet obj = {}\nlet date = new Date()\nlet reg = /\\d/\nlet arr = [1, 2, 3]\nlet fun = function () {\n}\n\nconsole.log(num.toString())   // &#39;1&#39;\nconsole.log(str.toString())   // &#39;a&#39;\nconsole.log(bool.toString())  // &#39;true&#39;\nconsole.log(obj.toString())   // &#39;[object Object]&#39;\nconsole.log(date.toString())  // &#39;Thu Mar 28 2019 17:07:40 GMT+0800 (中国标准时间)&#39;\nconsole.log(reg.toString())   // &#39;/\\d/&#39;\nconsole.log(arr.toString())   // &#39;1,2,3&#39;\nconsole.log(fun.toString())   // &#39;function(){}&#39;</code></pre><p>valueOf：valueOf()函数将对象转换为原始值</p>\n<ul>\n<li>Array 返回数组对象本身</li>\n<li>Boolean 布尔值</li>\n<li>Date 返回时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC</li>\n<li>Function 函数本身</li>\n<li>Number 数字值</li>\n<li>Object 对象本身，这是默认情况。</li>\n<li>String 字符串值</li>\n<li>Reg 正则本身</li>\n</ul>\n<p>如下代码演示（以下演示情况是valueOf方法没有被重写）</p>\n<pre><code>console.log(num.valueOf())   // 1\nconsole.log(str.valueOf())   // &#39;a&#39; \nconsole.log(bool.valueOf())  // true\nconsole.log(obj.valueOf())   // {}\nconsole.log(date.valueOf())  // 1553766610534\nconsole.log(reg.valueOf())   // /\\d/\nconsole.log(arr.valueOf())   // [1, 2, 3]\nconsole.log(fun.valueOf())   // fun()</code></pre><p>以上铺垫了这么多，是因为在隐式转换过程中经常会有用到调用对象的toString和valueOf方法</p>\n<h2 id="2-隐式转换规则">2. 隐式转换规则</h2>\n<p>以下为隐式转换时的规则：</p>\n<ol>\n<li>转化成字符串：使用字符串连接符 +</li>\n<li>转化成数字： </li>\n<li>1 ++/-- （自加/自减） 2.2 + - * / % （算术运算）2.3 &gt; &lt; &gt;= &lt;= == != === !== （关系运算符）</li>\n<li>转成布尔值：使用！非运算符</li>\n</ol>\n<h3 id="21-字符串连接符和算法运算符混淆">2.1 字符串连接符和算法运算符混淆</h3>\n<p>先看看以下代码：</p>\n<pre><code>let a = 1\nconsole.log(a + &#39;1&#39;)          // &#39;11&#39;\nconsole.log(a + null)         // 1\nconsole.log(a + undefined)    // NaN (Number(undefined) = NaN)\nconsole.log(a + true)         // 2\nconsole.log(a + {})           // &#39;1[object Object]&#39;\nconsole.log(a + [1, 2, 3])    // &#39;11,2,3&#39;\nconsole.log(a + new Date())   // &#39;1Fri Mar 29 2019 10:12:41 GMT+0800 (中国标准时间)&#39;\nconsole.log(a + /\\d/)         // &#39;1/\\d/&#39;\nconsole.log(a + function(){}) // &#39;1function(){}&#39;</code></pre><p>从打印的结果可以知道</p>\n<ol>\n<li>当 + 号为字符串连接符时，则调用对象的toString方法转化为字符串然后相加</li>\n<li>当 + 号为算术运算符时，则调用Number()方法转化然后相加</li>\n</ol>\n<p>在这里我们需要注意的是null、布尔值和undefined这三类对象使用 + 进行操作，当有一边确定为数字的时候，这三类值会尝试用Number()进行转化，<strong>如果有一边类型确定为字符串的时候，直接就是进行字符串相加</strong>。</p>\n<pre><code>let a = &#39;1&#39;\nconsole.log(a + null)         // &#39;1null&#39;\nconsole.log(a + undefined)    // &#39;1undefined&#39;\nconsole.log(a + true)         // &#39;1true&#39;</code></pre><h3 id="22-关系运算符会把其他数据类型转换成number之后再比较关系">2.2 关系运算符会把其他数据类型转换成number之后再比较关系</h3>\n<p>先看看以下代码：</p>\n<pre><code>console.log(&#39;2&#39; &gt; 10)    // false\nconsole.log(&#39;2&#39; &gt; &#39;10&#39;)  // true\nconsole.log(&#39;a&#39; &gt; &#39;b&#39;)   // false\nconsole.log(&#39;ab&#39; &gt; &#39;aa&#39;) // true</code></pre><p>从打印的结果可以知道</p>\n<ol>\n<li>当关系比较有一边为数字的时候，会把其他数据类型调用Number()转化为数字后进行运算</li>\n<li>当关系比较两边都为字符串的时候，会同时把字符串转化为数字进行比较，但是不是用Number()进行转化，而是按照字符串的unicode编码进行转化(string.charCodeAt,默认为字符的第一位)</li>\n</ol>\n<pre><code>console.log(&#39;a&#39; &gt; &#39;b&#39;)   // false\n// &#39;a&#39;.charCodeAt() &gt; &#39;b&#39;.charCodeAt()\nconsole.log(&#39;ab&#39; &gt; &#39;aa&#39;) // true\n// 第一位都是a相等，所以比较第二位的 b.charCodeAt() &gt; a.charCodeAt()</code></pre><h3 id="23-复杂数据类型在隐式转换时会先转成string，然后再转成number运算">2.3 复杂数据类型在隐式转换时会先转成String，然后再转成Number运算</h3>\n<p>复杂类型数据指的是对象或数组这类数据进行隐式转换时，会先调用valueOf后调用toString方法转化成数据，再调用Number()转化成数字进行运算。</p>\n<p>如果这个对象的valueOf方法和toString方法被重写过，则会根据valueOf返回的数据类型判断是否执行toString。</p>\n<p>接下来代码示范：</p>\n<pre><code>let a = {\n    valueOf: function () {\n        console.log(&#39;执行valueOf&#39;)\n        return &#39;a&#39;\n    },\n    toString: function () {\n        console.log(&#39;执行toString&#39;)\n        return &#39;a&#39;\n    }\n}\nconsole.log(a == &#39;a&#39;)\n// 执行valueOf\n// true</code></pre><p>接下来尝试把valueOf返回值改成数字：</p>\n<pre><code>let a = {\n    valueOf: function () {\n        console.log(&#39;执行valueOf&#39;)\n        return 1\n    },\n    toString: function () {\n        console.log(&#39;执行toString&#39;)\n        return &#39;a&#39;\n    }\n}\nconsole.log(a == &#39;a&#39;)\n// 执行valueOf\n// false</code></pre><p>尝试把valueOf返回值改成对象</p>\n<pre><code>let a = {\n    valueOf: function () {\n        console.log(&#39;执行valueOf&#39;)\n        return {}\n    },\n    toString: function () {\n        console.log(&#39;执行toString&#39;)\n        return &#39;a&#39;\n    }\n}\nconsole.log(a == &#39;a&#39;)\n// 执行valueOf\n// 执行toString\n// true</code></pre><p>通过上面的例子我们可以得出结论：</p>\n<ol>\n<li>valueOf返回的数据类型决定是否调用toString，如果返回的类型是数字或者字符串(其实用基础数据类型更准确点)，toString方法就不执行了。</li>\n<li>转化成字符串后再调用Number()转化成数字进行比较</li>\n</ol>\n<p>这里还有个问题就是如果toString方法返回不是基础类型，进行比较的时候则会报错。</p>\n<h3 id="24-逻辑非隐式转换与关系运算符隐式转换混淆">2.4 逻辑非隐式转换与关系运算符隐式转换混淆</h3>\n<p>当使用!逻辑非运算符进行转化的时候，会尝试把数据转化成布尔值</p>\n<p>以下情况使用Boolean()转化将会得到false</p>\n<p>0、-0、undefined、null、NaN、false、&#39;&#39;(空字符串)、document.all</p>\n<pre><code>console.log([] == 0)    // true\nconsole.log(![] == 0)   // true\n// [] == 0 --&gt; [].valueOf().toString()得到空字符串，Number(&#39;&#39;) == 0 成立\n// ![] == 0 --&gt; Boolean([])得到true再取反，最后转化成数字0，Number(!true) == 0 成立\n\nconsole.log([] == ![])  // true\nconsole.log([] == [])   // false\n// [] == ![] --&gt; [].valueOf().toString()得到空字符串，Number(&#39;&#39;)取得0，Boolean([])得到true再取反，转化成数字0，最后Number(&#39;&#39;) == Number(!true) 成立\n// [] == [] --&gt; 两个数组比较是因为两个数据的引用指向不一致，所以 [] == [] 不成立\n\nconsole.log({} == !{})  // false\nconsole.log({} == {})   // false\n// {} == !{} --&gt; {}.valueOf().toString()得到&#39;[object Object]&#39;，Boolean({})得到true再取反，所以 &#39;[object Object]&#39; == false 不成立\n// {} == {} --&gt; 两个对象比较是因为两个数据的引用指向不一致，所以 {} == {} 不成立</code></pre><p>最后总结一下，在复杂数据类型隐式转化过程中会调用valueOf和toString方法，所以如果这两个方法被改写了往往会得到一些意料外的结果。</p>\n'},"96cf":function(e,n,t){var o=function(e){"use strict";var n,t=Object.prototype,o=t.hasOwnProperty,r="function"===typeof Symbol?Symbol:{},c=r.iterator||"@@iterator",i=r.asyncIterator||"@@asyncIterator",d=r.toStringTag||"@@toStringTag";function s(e,n,t,o){var r=n&&n.prototype instanceof g?n:g,c=Object.create(r.prototype),i=new E(o||[]);return c._invoke=q(e,t,i),c}function a(e,n,t){try{return{type:"normal",arg:e.call(n,t)}}catch(o){return{type:"throw",arg:o}}}e.wrap=s;var l="suspendedStart",p="suspendedYield",u="executing",h="completed",f={};function g(){}function m(){}function b(){}var v={};v[c]=function(){return this};var x=Object.getPrototypeOf,w=x&&x(x(O([])));w&&w!==t&&o.call(w,c)&&(v=w);var y=b.prototype=g.prototype=Object.create(v);function k(e){["next","throw","return"].forEach(function(n){e[n]=function(e){return this._invoke(n,e)}})}function S(e){function n(t,r,c,i){var d=a(e[t],e,r);if("throw"!==d.type){var s=d.arg,l=s.value;return l&&"object"===typeof l&&o.call(l,"__await")?Promise.resolve(l.__await).then(function(e){n("next",e,c,i)},function(e){n("throw",e,c,i)}):Promise.resolve(l).then(function(e){s.value=e,c(s)},function(e){return n("throw",e,c,i)})}i(d.arg)}var t;function r(e,o){function r(){return new Promise(function(t,r){n(e,o,t,r)})}return t=t?t.then(r,r):r()}this._invoke=r}function q(e,n,t){var o=l;return function(r,c){if(o===u)throw new Error("Generator is already running");if(o===h){if("throw"===r)throw c;return C()}t.method=r,t.arg=c;while(1){var i=t.delegate;if(i){var d=T(i,t);if(d){if(d===f)continue;return d}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if(o===l)throw o=h,t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);o=u;var s=a(e,n,t);if("normal"===s.type){if(o=t.done?h:p,s.arg===f)continue;return{value:s.arg,done:t.done}}"throw"===s.type&&(o=h,t.method="throw",t.arg=s.arg)}}}function T(e,t){var o=e.iterator[t.method];if(o===n){if(t.delegate=null,"throw"===t.method){if(e.iterator["return"]&&(t.method="return",t.arg=n,T(e,t),"throw"===t.method))return f;t.method="throw",t.arg=new TypeError("The iterator does not provide a 'throw' method")}return f}var r=a(o,e.iterator,t.arg);if("throw"===r.type)return t.method="throw",t.arg=r.arg,t.delegate=null,f;var c=r.arg;return c?c.done?(t[e.resultName]=c.value,t.next=e.nextLoc,"return"!==t.method&&(t.method="next",t.arg=n),t.delegate=null,f):c:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,f)}function _(e){var n={tryLoc:e[0]};1 in e&&(n.catchLoc=e[1]),2 in e&&(n.finallyLoc=e[2],n.afterLoc=e[3]),this.tryEntries.push(n)}function V(e){var n=e.completion||{};n.type="normal",delete n.arg,e.completion=n}function E(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(_,this),this.reset(!0)}function O(e){if(e){var t=e[c];if(t)return t.call(e);if("function"===typeof e.next)return e;if(!isNaN(e.length)){var r=-1,i=function t(){while(++r<e.length)if(o.call(e,r))return t.value=e[r],t.done=!1,t;return t.value=n,t.done=!0,t};return i.next=i}}return{next:C}}function C(){return{value:n,done:!0}}return m.prototype=y.constructor=b,b.constructor=m,b[d]=m.displayName="GeneratorFunction",e.isGeneratorFunction=function(e){var n="function"===typeof e&&e.constructor;return!!n&&(n===m||"GeneratorFunction"===(n.displayName||n.name))},e.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,b):(e.__proto__=b,d in e||(e[d]="GeneratorFunction")),e.prototype=Object.create(y),e},e.awrap=function(e){return{__await:e}},k(S.prototype),S.prototype[i]=function(){return this},e.AsyncIterator=S,e.async=function(n,t,o,r){var c=new S(s(n,t,o,r));return e.isGeneratorFunction(t)?c:c.next().then(function(e){return e.done?e.value:c.next()})},k(y),y[d]="Generator",y[c]=function(){return this},y.toString=function(){return"[object Generator]"},e.keys=function(e){var n=[];for(var t in e)n.push(t);return n.reverse(),function t(){while(n.length){var o=n.pop();if(o in e)return t.value=o,t.done=!1,t}return t.done=!0,t}},e.values=O,E.prototype={constructor:E,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=n,this.done=!1,this.delegate=null,this.method="next",this.arg=n,this.tryEntries.forEach(V),!e)for(var t in this)"t"===t.charAt(0)&&o.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=n)},stop:function(){this.done=!0;var e=this.tryEntries[0],n=e.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var t=this;function r(o,r){return d.type="throw",d.arg=e,t.next=o,r&&(t.method="next",t.arg=n),!!r}for(var c=this.tryEntries.length-1;c>=0;--c){var i=this.tryEntries[c],d=i.completion;if("root"===i.tryLoc)return r("end");if(i.tryLoc<=this.prev){var s=o.call(i,"catchLoc"),a=o.call(i,"finallyLoc");if(s&&a){if(this.prev<i.catchLoc)return r(i.catchLoc,!0);if(this.prev<i.finallyLoc)return r(i.finallyLoc)}else if(s){if(this.prev<i.catchLoc)return r(i.catchLoc,!0)}else{if(!a)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return r(i.finallyLoc)}}}},abrupt:function(e,n){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc<=this.prev&&o.call(r,"finallyLoc")&&this.prev<r.finallyLoc){var c=r;break}}c&&("break"===e||"continue"===e)&&c.tryLoc<=n&&n<=c.finallyLoc&&(c=null);var i=c?c.completion:{};return i.type=e,i.arg=n,c?(this.method="next",this.next=c.finallyLoc,f):this.complete(i)},complete:function(e,n){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&n&&(this.next=n),f},finish:function(e){for(var n=this.tryEntries.length-1;n>=0;--n){var t=this.tryEntries[n];if(t.finallyLoc===e)return this.complete(t.completion,t.afterLoc),V(t),f}},catch:function(e){for(var n=this.tryEntries.length-1;n>=0;--n){var t=this.tryEntries[n];if(t.tryLoc===e){var o=t.completion;if("throw"===o.type){var r=o.arg;V(t)}return r}}throw new Error("illegal catch attempt")},delegateYield:function(e,t,o){return this.delegate={iterator:O(e),resultName:t,nextLoc:o},"next"===this.method&&(this.arg=n),f}},e}(e.exports);try{regeneratorRuntime=o}catch(r){Function("r","regeneratorRuntime = r")(o)}},"9c25":function(e,n,t){"use strict";t.r(n),n["default"]='<blockquote>\n<p>因为本人开发中使用的是VUE技术栈，最近也是开始源码的学习，以此记录个人理解，若行文有误，请多多指教。</p>\n</blockquote>\n<h2 id="1new-router和install">1.new Router和install</h2>\n<p>在vue中我们使用vue-router时需要先进行<code>new Router()</code>，执行<code>new Router()</code>后主要执行代码看看VueRouter class定义的<code>constructor</code>方法。</p>\n<pre><code>constructor (options: RouterOptions = {}) {\n    this.app = null\n    this.apps = []\n    this.options = options\n    this.beforeHooks = []\n    this.resolveHooks = []\n    this.afterHooks = []\n    this.matcher = createMatcher(options.routes || [], this)\n\n    let mode = options.mode || &#39;hash&#39;\n    this.fallback = mode === &#39;history&#39; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false\n    if (this.fallback) {\n      mode = &#39;hash&#39;\n    }\n    if (!inBrowser) {\n      mode = &#39;abstract&#39;\n    }\n    this.mode = mode\n\n    switch (mode) {\n      case &#39;history&#39;:\n        this.history = new HTML5History(this, options.base)\n        break\n      case &#39;hash&#39;:\n        this.history = new HashHistory(this, options.base, this.fallback)\n        break\n      case &#39;abstract&#39;:\n        this.history = new AbstractHistory(this, options.base)\n        break\n      default:\n        if (process.env.NODE_ENV !== &#39;production&#39;) {\n          assert(false, `invalid mode: ${mode}`)\n        }\n    }\n  }</code></pre><p>从代码里面我们可以看到在<code>new</code>的时候确定了使用何种路由模式，并且根据传入options创建<code>matcher</code>。</p>\n<p>接下来看看当使用<code>vue.use()</code>执行install方法做了什么：</p>\n<pre><code>export function install (Vue) {\n  if (install.installed &amp;&amp; _Vue === Vue) return\n  install.installed = true\n\n  _Vue = Vue\n\n  const isDef = v =&gt; v !== undefined\n\n  const registerInstance = (vm, callVal) =&gt; {\n    let i = vm.$options._parentVnode\n    if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal)\n    }\n  }\n\n  Vue.mixin({\n    beforeCreate () {\n      if (isDef(this.$options.router)) {\n        this._routerRoot = this\n        this._router = this.$options.router\n        this._router.init(this)\n        Vue.util.defineReactive(this, &#39;_route&#39;, this._router.history.current)\n      } else {\n        this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this\n      }\n      registerInstance(this, this)\n    },\n    destroyed () {\n      registerInstance(this)\n    }\n  })\n\n  Object.defineProperty(Vue.prototype, &#39;$router&#39;, {\n    get () { return this._routerRoot._router }\n  })\n\n  Object.defineProperty(Vue.prototype, &#39;$route&#39;, {\n    get () { return this._routerRoot._route }\n  })\n\n  Vue.component(&#39;RouterView&#39;, View)\n  Vue.component(&#39;RouterLink&#39;, Link)\n\n  const strats = Vue.config.optionMergeStrategies\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created\n}</code></pre><p><code>install</code>方法里主要是<code>Vue.mixin</code>给每个组件混入了<code>beforeCreate</code>和 <code>destroyed </code>方法，在Vue的原型链上增加了<code>$router</code>和<code>$route</code>对象，这就是为什么我们使用Vue的时候在this上可以拿到这两个对象，注册了<code>router-view</code>和<code>router-link</code>两个组件。</p>\n<h2 id="2-matcher和route">2. matcher和route</h2>\n<p>接下来看看<code>matcher</code>的定义：</p>\n<pre><code>export type Matcher = {\n  match: (raw: RawLocation, current?: Route, redirectedFrom?: Location) =&gt; Route;\n  addRoutes: (routes: Array&lt;RouteConfig&gt;) =&gt; void;\n};</code></pre><p><code>matcher</code>暴露了<code>match</code>方法<code>addRoutes</code>方法，从方法的名字上看，match方法是用于路由匹配，addRoutes则是用来添加路由配置。</p>\n<p>在执行<code>creatMatcher()</code>里第一代段代码生成了<code>pathList</code>、<code>pathMap</code>、<code>nameMap</code>这三个对象，这是后面路由执行匹配非常重要的配置。</p>\n<pre><code>  const { pathList, pathMap, nameMap } = createRouteMap(routes)</code></pre><p><code>pathMap</code>和<code>nameMap</code>分别是以route配置的path和name为key生成的一个映射表，对应value为<code>RouteRecord</code>实例。</p>\n<p>下面看看<code>RouteRecord</code>的定义：</p>\n<pre><code>declare type RouteRecord = {\n  path: string;\n  regex: RouteRegExp;\n  components: Dictionary&lt;any&gt;;\n  instances: Dictionary&lt;any&gt;;\n  name: ?string;\n  parent: ?RouteRecord;\n  redirect: ?RedirectOption;\n  matchAs: ?string;\n  beforeEnter: ?NavigationGuard;\n  meta: any;\n  props: boolean | Object | Function | Dictionary&lt;boolean | Object | Function&gt;;\n}</code></pre><p>结合代码里的实际数据对照理解各个属性的含义：</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/6/7/16b318773604a842?w=1598&h=522&f=png&s=132269" alt=""></p>\n<table>\n<thead>\n<tr>\n<th>key</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>path</td>\n<td>传入的路径值</td>\n</tr>\n<tr>\n<td>regex</td>\n<td>根据path生成的正则匹配规则</td>\n</tr>\n<tr>\n<td>components</td>\n<td>path对应的组件</td>\n</tr>\n<tr>\n<td>instances</td>\n<td>执行路由守卫方法时传入的route实例</td>\n</tr>\n<tr>\n<td>name</td>\n<td>route的name</td>\n</tr>\n<tr>\n<td>parent</td>\n<td>route的父级，是一个递归的对象，从最底层一直到最顶层，无则为undefined</td>\n</tr>\n<tr>\n<td>redirect</td>\n<td>重定向的路径</td>\n</tr>\n<tr>\n<td>matchAs</td>\n<td>用于匹配alias</td>\n</tr>\n<tr>\n<td>props</td>\n<td>传入路由的参数</td>\n</tr>\n</tbody></table>\n<p>结合以上解释，我们可以得出<code>vue-router</code>一个大概的运行概念。</p>\n<ol>\n<li><p>执行<code>new Router()</code>生成路由配置对象<code>routedRecord</code></p>\n</li>\n<li><p>路由匹配根据<code>route</code>对象的<code>regex</code>进行匹配</p>\n</li>\n<li><p>根据<code>route</code>的<code>parent</code>对象递归获取<code>component</code>组件生成<code>render Tree</code></p>\n</li>\n<li><p>执行各组件对应的导航守卫方法</p>\n</li>\n</ol>\n<p>此文大概简述了vue-router是如何执行的，但是对于router跳转的具体执行并没有进行深入解释，下一篇文章将会详细说明router跳转之后是如何执行。</p>\n'},a0c2:function(e,n,t){"use strict";var o=t("78b0"),r=t.n(o);r.a},a22a:function(e,n,t){var o=t("d864"),r=t("b0dc"),c=t("3702"),i=t("e4ae"),d=t("b447"),s=t("7cd6"),a={},l={};n=e.exports=function(e,n,t,p,u){var h,f,g,m,b=u?function(){return e}:s(e),v=o(t,p,n?2:1),x=0;if("function"!=typeof b)throw TypeError(e+" is not iterable!");if(c(b)){for(h=d(e.length);h>x;x++)if(m=n?v(i(f=e[x])[0],f[1]):v(e[x]),m===a||m===l)return m}else for(g=b.call(e);!(f=g.next()).done;)if(m=r(g,v,f.value,n),m===a||m===l)return m};n.BREAK=a,n.RETURN=l},a522:function(e,n,t){"use strict";t.r(n),n["default"]='<p>异步，已经是js里变成必不可少的，而说到异步我们就不得不来说说js的event loop机制。</p>\n<p>首先，一定要记住的一点：<strong>js是单线程的。</strong></p>\n<p>在event loop机制里，还涉及到宏任务（task）和微任务（Microtasks）概念，具体概念本文不作解释，说下属于这两个类型的分类：</p>\n<ol>\n<li>宏任务：script、setTimeout、setInterval</li>\n<li>微任务：Promise.then()、process.nextTick()</li>\n</ol>\n<p>event loop在执行的时候先执行当前宏任务中的同步代码，碰到属于异步的代码，则先判断是属于宏任务还是微任务，然后注册新的任务到任务队列中。当前同步代码执行完成后将执行当前宏任务的微任务队列，直到微任务队列为空时我们将执行一个新的宏任务队列。</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/4/6/169f0f290787f313?w=800&h=658&f=jpeg&s=42740" alt=""></p>\n<p>接下来就让我们用代码来理解event loop到底是怎么回事。</p>\n<pre><code>console.log(1)\n\nsetTimeout(function () {\n    console.log(2)\n})\n\nconsole.log(3)</code></pre><p>看到这段代码我们很容易知道答案</p>\n<pre><code>// 1 3 2</code></pre><p>在这段代码里，setTimeout设置了一个定时任务（宏任务），将延迟多少时间后执行。</p>\n<p>接下来再把promise加进来看看</p>\n<pre><code>console.log(1)\n\nsetTimeout(function () {\n    console.log(2)\n})\n\nconsole.log(3)\n\nnew Promise(function (resolve, reject) {\n    console.log(4)\n    resolve()\n}).then(function () {\n    console.log(5)\n})\n\nconsole.log(6)</code></pre><p>这里打印的结果是:</p>\n<pre><code>// 1 3 4 6 5 2</code></pre><p>接下来我们对结果进行分析</p>\n<p>首先执行同步的代码，new Promise()中的代码属于同步任务，所以先打印出1 3 4 6；当前代码有2个异步代码，setTimeout和Promise.then()，前面我们已经说过，setTimeout属于宏任务，Promise.then属于微任务，所以当前宏任务队列执行完后将执行当前队列的微任务。</p>\n<p>所以最后部分打印结果 5 2</p>\n<p>接下来再看一个例子：</p>\n<pre><code>console.log(1)\n\nsetTimeout(function () {\n    console.log(2)\n})\n\nconsole.log(3)\n\nnew Promise(function (resolve, reject) {\n    console.log(4)\n    setTimeout(function () {\n        console.log(5)\n    })\n    resolve()\n}).then(function () {\n    console.log(6)\n    setTimeout(function () {\n        console.log(7)\n    })\n})\n\nconsole.log(8)</code></pre><p>打印结果为：</p>\n<pre><code>// 1 3 4 8 6 2 5 7</code></pre><p>分析的结果和上一部分代码是一样的，setTimeout属于宏任务将在当前宏任务执行完成后执行，执行顺序和注册任务的先后顺序有关。</p>\n<p>最后再两个例子说明script和setTimeout属于宏任务类型</p>\n<p>第一个例子</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script&gt;\n    console.log(1)\n\n    setTimeout(function () {\n        console.log(2)\n    })\n\n    console.log(3)\n\n    new Promise(function (resolve, reject) {\n        console.log(4)\n        resolve()\n    }).then(function () {\n        console.log(5)\n        setTimeout(function () {\n            console.log(7)\n        })\n        new Promise(function (resolve, reject) {\n            console.log(8)\n            resolve()\n        }).then(function () {\n            console.log(9)\n        })\n    })\n\n    if (true) console.log(6)\n&lt;/script&gt;\n&lt;script src=&quot;index2.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>第二个例子</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;script&gt;\nconsole.log(1)\n\nsetTimeout(function () {\n    console.log(2)\n    let node = document.createElement(&#39;script&#39;)\n    node.src = &#39;./index2.js&#39;\n    document.body.append(node)\n})\n\nconsole.log(3)\n\nnew Promise(function (resolve, reject) {\n    console.log(4)\n    resolve()\n}).then(function () {\n    console.log(5)\n    setTimeout(function () {\n        console.log(7)\n    })\n    new Promise(function (resolve, reject) {\n        console.log(8)\n        resolve()\n    }).then(function () {\n        console.log(9)\n    })\n})\n\nif(true) console.log(6)\n&lt;/script&gt;\n&lt;script src=&quot;index2.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>index2.js的代码如下</p>\n<pre><code>console.log(1)\n\nsetTimeout(function () {\n    console.log(2)\n})\n\nconsole.log(3)\n\nnew Promise(function (resolve, reject) {\n    console.log(4)\n    resolve()\n}).then(function () {\n    console.log(5)\n    setTimeout(function () {\n        console.log(7)\n    })\n    new Promise(function (resolve, reject) {\n        console.log(8)\n        resolve()\n    }).then(function () {\n        console.log(9)\n    })\n})\n\nif(true) console.log(6)</code></pre><p>在这两个例子中setTimeout的执行顺序和我们script创建时的顺序有关，根据event loop的执行机制分析即可。</p>\n'},a891:function(e,n,t){},aba2:function(e,n,t){var o=t("e53d"),r=t("4178").set,c=o.MutationObserver||o.WebKitMutationObserver,i=o.process,d=o.Promise,s="process"==t("6b4c")(i);e.exports=function(){var e,n,t,a=function(){var o,r;s&&(o=i.domain)&&o.exit();while(e){r=e.fn,e=e.next;try{r()}catch(c){throw e?t():n=void 0,c}}n=void 0,o&&o.enter()};if(s)t=function(){i.nextTick(a)};else if(!c||o.navigator&&o.navigator.standalone)if(d&&d.resolve){var l=d.resolve(void 0);t=function(){l.then(a)}}else t=function(){r.call(o,a)};else{var p=!0,u=document.createTextNode("");new c(a).observe(u,{characterData:!0}),t=function(){u.data=p=!p}}return function(o){var r={fn:o,next:void 0};n&&(n.next=r),e||(e=r,t()),n=r}}},b0f1:function(e,n,t){"use strict";t.r(n),n["default"]='<h2 id="正则里括号的用法">正则里括号的用法</h2>\n<h3 id="1-分组">1. 分组</h3>\n<p>分组：正则表达式里括号的表达式为另外一组匹配规则</p>\n<p>捕获括号：被匹配的子字符串可以在结果数组的元素 [1]-[n] 中找到，或在被定义的 RegExp 对象的属性 $1-$9 中找到。</p>\n<p>代码举例：</p>\n<pre><code>let reg = /\\d+(\\D+)/\nreg.exec(&#39;123456abcd&#39;)\n// [&quot;123456abcd&quot;, &quot;abcd&quot;, index: 0, input: &quot;123456abcd&quot;, groups: undefined]\nconsole.log(RegExp.$1)\n// &quot;abcd&quot;</code></pre><p>在这个正则表达式里我们括号期望的是一组非数字的匹配项，并且执行匹配后可在执行结果的[1]或者RegExp.$1得到匹配值。</p>\n<p>正则表达式括号的分组在实际开发中对于我们解决问题有非常大的用处，例如String.replace()这个方法</p>\n<p>代码举例：</p>\n<pre><code>let str = &#39;123abc&#39;\nlet reg = /(\\d+)(\\D+)/\nlet newStr = str.replace(reg, &#39;$2$1&#39;)\nconsole.log(newStr) // abc123\nstr.replace(reg, function(word, $1, $2){\n    console.log(word,$1,$2)\n    // word代表字符串在正则匹配到的值, $1代表第一个括号的匹配项, $2代表第二个括号的匹配项\n    // 123abc, 123, abc\n})</code></pre><p>使用正则表达式应用于字符串处理，在上面的例子里我们很容易得就把数字和字母的匹配项互换位置。</p>\n<p>在另外一种情况下如果不想要捕获这个匹配项，但是又需要加括号匹配条件，我们可以使用非捕获括号</p>\n<p>非捕获括号：匹配项不能够从结果数组的元素 [1]-[n] 或已被定义的 RegExp 对象的属性 $1-$9 再次访问到。</p>\n<p>代码举例：</p>\n<pre><code>let reg = /\\d+(?:\\D+)/\nreg.exec(&#39;123456abcd&#39;)\n// [&quot;123456abcd&quot;, index: 0, input: &quot;123456abcd&quot;, groups: undefined]</code></pre><p>在例子里执行匹配后括号里的匹配项不会再出现结果里。</p>\n<h3 id="2反向引用">2.反向引用</h3>\n<p>反向引用：一个反向引用（back reference），指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。</p>\n<p>代码举例：</p>\n<pre><code>reg = /(\\d+)\\D+\\1/\nreg.exec(&#39;123abc123&#39;)\n// [&quot;123abc123&quot;, &quot;123&quot;, index: 0, input: &quot;123abc123&quot;, groups: undefined]</code></pre><p>在正则表达式里\\1代表的是\\d+，当我们在表达式里有需要重复的时候可以用这种写法。</p>\n<h3 id="3零宽断言">3.零宽断言</h3>\n<p>零宽断言：指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。</p>\n<ol>\n<li>(?=pattern) 正向先行断言：代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配pattern。</li>\n<li>(?!pattern) 负向先行断言：代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配pattern。</li>\n<li>(?&lt;=pattern) 正向后行断言：代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配pattern。</li>\n<li>(?&lt;!pattern) 负向后行断言：代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配pattern。</li>\n</ol>\n<p>正则表达式的括号有时候用来表达断言，具体的细节我们在下面问内容详细说。</p>\n<h2 id="贪婪模式与非贪婪模式">贪婪模式与非贪婪模式</h2>\n<p>贪婪模式与非贪婪模式也是正则里面比较常见的问题了，平时也会经常应用于开发中解决问题。理解贪婪模式和非贪婪模式对我们理解正则引擎执行匹配非常有帮助。</p>\n<h3 id="贪婪模式">贪婪模式</h3>\n<p>贪婪模式会匹配尽可能多的字符，贪婪模式用于匹配优先量词修饰的子表达式，匹配优先量词包括：“{m，n}”、“{m，}”、“?”、“*”和“+”</p>\n<p>代码举例：</p>\n<pre><code>let reg = /\\d*/\nreg.exec(&#39;1234567890&#39;)\n[&quot;1234567890&quot;, index: 0, input: &quot;1234567890&quot;, groups: undefined]</code></pre><p>*号代表匹配任意次数，用大括号代表即{0,}，在贪婪模式下尽可能多的匹配，在例子中因为整个字符串完全匹配，所以匹配值为 1234567890。</p>\n<h3 id="非贪婪模式">非贪婪模式</h3>\n<p>非贪婪模式会匹配尽可能少的字符，在匹配量词后面加上问号就可触发非贪婪模式：“{m，n}?”、“{m，}?”、“??”、“*?”和“+?”</p>\n<p>代码举例：</p>\n<pre><code>let reg = /\\d*?/\nreg.exec(&#39;1234567890&#39;)\n// [&quot;&quot;, index: 0, input: &quot;1234567890&quot;, groups: undefined]</code></pre><p>*号代表匹配任意次数，用大括号代表即{0,}，因为*号可代表匹配0次，在非贪婪模式下尽可能少的匹配，所以在这个例子里匹配项为空，即不匹配任何字符串。</p>\n<h2 id="零宽断言">零宽断言</h2>\n<p>正则表达式的断言功能非常强大，学习正则的断言应用，对于解决我们开发中的问题提供了新的思路。</p>\n<p>在理解断言的执行过程可能会稍微有点绕，但是作为一个开发肯定要有一颗爱折腾的心，哈哈。</p>\n<p>下面将只使用正向先行断言来说明断言的执行，其他的三个模式也是大同小异。</p>\n<p>先看一个简单例子：</p>\n<pre><code>let reg = /abc(?=123)/\nreg.exec(&#39;abc123&#39;)\n// [&quot;abc&quot;, index: 0, input: &quot;abc123&quot;, groups: undefined]\n\nlet reg2 = /abc(?=1234)/\nreg2.exec(&#39;abc123&#39;)\n// null\n\nlet reg3 = /abc(?=12)/\nreg3.exec(&#39;abc123&#39;)\n// [&quot;abc&quot;, index: 0, input: &quot;abc123&quot;, groups: undefined]</code></pre><p>先按照正则的字面意思理解，/abc(?=123)/期望的匹配为即匹配abc，<strong>且abc后面的字符串能够满足括号的匹配规则</strong>，注意的是括号里面可以为其他<strong>正则表达式</strong>，并不是说abc后面只能包含123，而是后面可以满足括号的匹配则为断言成功。</p>\n<p>在reg2的匹配过程中，因为abc后面的字符串不满足括号的匹配规则，所以断言失败，执行匹配也失败了。</p>\n<p>在这几个例子里还没有体现出我们概念里说的意思，重温一下正向先行断言的概念</p>\n<p>(?=pattern) 正向先行断言：代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配pattern</p>\n<p>概念里说的意思断言是在字符串中寻找符合断言的一个位置</p>\n<p>举例说明：</p>\n<pre><code>let reg = /(?=abc).*/\nreg.exec(&#39;123abc123&#39;)\n// [&quot;abc123&quot;, index: 3, input: &quot;123abc123&quot;, groups: undefined]</code></pre><p>先分析正则表达式，在满足abc匹配条件的位置后面匹配任意字符。在这个例子里，存在abc满足断言的匹配规则，但是为什么匹配到的是abc123？</p>\n<p>在这里就回到我们的标题，零宽断言，零宽的意思就是执行断言是不会消耗我们正则表达式在匹配过程中的字符串，并且，断言是在帮我们确定符合断言匹配规则的位置。所以，(?=abc)会帮我们确定一个断言成功的位置，即3和a之间的位置，然后在这个断言成功的位置开始执行匹配（.*）。</p>\n<pre><code>let reg = /(?=abc)\\d+/\nreg.exec(&#39;123abc123&#39;)\n// null</code></pre><p>在上面的例子中，虽然abc的断言成功，但是断言只是帮我们确定一个位置，然后再执行\\d+匹配规则，因为断言是不会消耗字符串，所以实际上以abc123去和\\d+匹配，最后匹配结果为null。</p>\n<p>基于此我们可以使用断言帮我们从一开始检索整个字符串是否满足某些规则，有助于提升匹配效率。</p>\n<p>如下例子，我们可以使用断言从一开始判断整个字符串是否全部由数字组成，如果断言失败，则不执行匹配，这对于我们应用于表单校验非常有助于提升效率。</p>\n<pre><code>reg = /(?=^\\d+$)\\d+/\nreg.exec(&#39;123456&#39;)  // 123456\nreg.exec(&#39;123456a&#39;) // null</code></pre><p>另外没有介绍到的三种模式也是大同小异，在这里也就不重复赘述。但是两种后行断言可能会存在兼容性问题，后行断言应该是ES2018新增的规范。</p>\n<p>零宽断言的重点是要理解“<strong>零宽</strong>”以及“<strong>位置</strong>”这两个点。</p>\n<p>最后总结一下：正则表达式是一门非常实用的工具语言，基本上只要学习了就能够对于我们实际开发中产生帮助，平时某些开发工具中也可以使用正则表达式去检索某些文档，对于提升效率真的是帮助非常大。</p>\n'},b8c8:function(e,n,t){"use strict";t.r(n),n["default"]='<h2 id="为什么会有http缓存？">为什么会有HTTP缓存？</h2>\n<p>HTTP缓存的存在是因为web前端的性能瓶颈大部分的原因在于HTTP传输的时间耗费过长。如果能够减少这种HTTP请求的时间，对网页的性能来说是非常大的提升，对于用户的体验也能得到极大的改善。</p>\n<h2 id="http缓存标识">HTTP缓存标识</h2>\n<p>HTTP缓存可分为<font color=blue>强缓存</font>（Cache-Control和Expires）以及<font color=blue>协商缓存</font>（Etag和Last-Modified）。</p>\n<p>强缓存和协商缓存的区别在于：如果命中强缓存，会直接从缓存中读取资源，不向服务器请求。协商缓存则会向服务器请求确认资源是否过期。这也是缓存验证的顺序，先使用强缓存，后使用协商缓存。</p>\n<p>下面则简单介绍一下这两种缓存类型的标识</p>\n<h3 id="cache-control">Cache-Control</h3>\n<p>Cache-Control设置有效期max-age的值是时间的相对值。</p>\n<p>下面则简单介绍Cache-Control常用的使用值：</p>\n<table>\n<thead>\n<tr>\n<th>value</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public</td>\n<td>表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。</td>\n</tr>\n<tr>\n<td>private</td>\n<td>表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）,可以缓存响应内容。</td>\n</tr>\n<tr>\n<td>no-cache</td>\n<td>在发布缓存副本之前，强制高速缓存将请求提交给原始服务器进行验证。</td>\n</tr>\n<tr>\n<td>no-store</td>\n<td>缓存不应存储有关客户端请求或服务器响应的任何内容。</td>\n</tr>\n<tr>\n<td>max-age=&lt;seconds&gt;</td>\n<td>设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。</td>\n</tr>\n<tr>\n<td>must-revalidate</td>\n<td>缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。</td>\n</tr>\n<tr>\n<td>proxy-revalidate</td>\n<td>与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。</td>\n</tr>\n</tbody></table>\n<p>若想了解更详细的说明，可参考此链接：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control</a></p>\n<h3 id="expires">Expires</h3>\n<p>Expires 响应头包含日期/时间， 即在此时候之后，响应过期。</p>\n<p>Expires设置的值是一个绝对值。</p>\n<pre><code>Expires: Wed, 21 Oct 2015 07:28:00 GMT</code></pre><h3 id="etag">Etag</h3>\n<p>Etag HTTP响应头是资源的特定版本的标识符。这可以让缓存更高效，并节省带宽，因为如果内容没有改变，Web服务器不需要发送完整的响应。而如果内容发生了变化，使用ETag有助于防止资源的同时更新相互覆盖（“空中碰撞”）。</p>\n<p>Etag的值是根据资源文件内容生成的一个hash值。</p>\n<pre><code>Etag: 33a64df551425fcc55e4d42a148795d9f25f89d4</code></pre><h3 id="last-modified">Last-Modified</h3>\n<p>Last-Modified包含源头服务器认定的资源做出修改的日期及时间。 它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。由于精确度比  ETag 要低，所以这是一个备用机制。</p>\n<p>Last-Modified的值是一个时间的绝对值。</p>\n<pre><code>Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</code></pre><h2 id="http缓存验证规则">HTTP缓存验证规则</h2>\n<h3 id="http缓存的验证顺序">HTTP缓存的验证顺序</h3>\n<ol>\n<li>先使用强缓存（Cache-Control &gt; Expires） 判断资源是否过期；</li>\n<li>若资源未过期则直接从缓存读取，若资源过期则使用协商缓存；</li>\n<li>使用协商缓存（Etag &gt; Last-Modified）请求服务器确认资源有无修改（请求头会带上 If-None-Match 或 If-Modified-Since）；</li>\n<li>若资源无修改则返回 <code>304</code> 状态码告诉客户端可读取缓存；若资源已修改则返回 <code>200</code> 状态码重新获取资源；</li>\n</ol>\n<p>图示：</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/5/18/16ac9fe6feb72d69?w=1398&h=1298&f=png&s=344446" alt="">\n图片来源：<a href="https://www.cnblogs.com/xiaohuochai/p/6178810.html">https://www.cnblogs.com/xiaohuochai/p/6178810.html</a></p>\n<h3 id="http缓存验证说明">HTTP缓存验证说明</h3>\n<p>以下的HTTP缓存验证说明是基于假设请求存在4个缓存头标记；</p>\n<ol>\n<li>HTTP缓存是否过期，先判断Cache-Control是否设置<code>max-age</code>或<code>s-max-age</code>，如果已设置则忽略Expires并且验证是否过期，否则验证Expires是否过期；其实按照MDN文档的说明，Last-Modified也是可以计算出一个缓存时间；</li>\n</ol>\n<p>下面是MDN文档的说明：</p>\n<blockquote>\n<p>对于含有特定头信息的请求，会去计算缓存寿命。比如Cache-control: max-age=N的头，相应的缓存的寿命就是N。通常情况下，对于不含这个属性的请求则会去查看是否包含Expires属性，通过比较Expires的值和头里面Date属性的值来判断是否缓存还有效。如果max-age和expires属性都没有，找找头里的Last-Modified信息。如果有，缓存的寿命就等于头里面Date的值减去Last-Modified的值除以10（注：根据rfc2626其实也就是乘以10%）。</p>\n</blockquote>\n<p>缓存时间计算公式：</p>\n<blockquote>\n<p>expirationTime = responseTime + freshnessLifetime - currentAge</p>\n</blockquote>\n<ol start="2">\n<li>如果该缓存未过期，是不会向服务器发送请求的，而是直接从缓存中读取，也就是我们可以从HTTP请求信息里得到的状态码 <code> 200 (from cache memory || from disk memory) </code>，如果缓存过期，则使用协商缓存；</li>\n</ol>\n<ul>\n<li>先尝试从内存中读取，再尝试从硬盘中读取。</li>\n<li>200 form memory cache 不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。</li>\n<li>200 from disk cache 不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。</li>\n</ul>\n<ol start="3">\n<li>使用协商缓存验证缓存资源是否修改；<font color=red>Etag &gt; Last-Modified</font>，当存在Etag则使用Etag，否则使用Last-Modified；并且请求时会带上特定的标识；</li>\n</ol>\n<ul>\n<li>Etag 请求时会带上 If-None-Match</li>\n<li>Last-Modified 请求时会带上 If-Modified-Since</li>\n</ul>\n<ol start="4">\n<li>当确认资源未修改时则返回 <code> 304 (Not Modified)</code>告诉客户端可以继续使用缓存，否则返回<code>200</code>重新获取新的资源。</li>\n</ol>\n<p>HTTP缓存早期的时候只有Expires和Last-Modified，为什么后面又会出现Cache-Control和Etag呢？</p>\n<p>先说说Expires和Cache-Control，Expires的值是一个准确的时间，比较的时候先根据返回头的Date值比较判断，但是若无Date头信息返回则是根据客户端的本地时间进行比较；本地时间因为各种因素影响，会存在各种不同的值，导致Expires缓存的时间并不是我们想要的效果。而Cache-Control设置max-age使用的相对值则相对来说控制粒度更精确了；并且Cache-Control的其他值则让我们对于缓存的控制更加灵活。</p>\n<p>再说说Last-Modified和Etag，Last-Modified的值也是一个准确的时间，精确到秒；使用时间来判断资源是否修改则可能存在以下问题：</p>\n<ol>\n<li>1秒内的修改可能不被检查到，导致缓存无法更新；</li>\n<li>资源可能只是多了几个空格或无变化，但是Last-Modified的时间已经变化；</li>\n</ol>\n<p>针对以上的问题所以有了Etag的存在，Etag是根据资源内容生成的hash值对比判断资源是否更新，控制粒度比Last-Modified更加精确。</p>\n<h2 id="总结">总结</h2>\n<p>HTTP缓存的本质上是以空间换时间，缓存的存在是为了尽可能的减少HTTP请求次数和HTTP传输的内容大小，这也是前端性能优化中重要的一环。合理的设置页面资源的缓存，有助你提升页面的体验。</p>\n'},bc13:function(e,n,t){var o=t("e53d"),r=o.navigator;e.exports=r&&r.userAgent||""},c207:function(e,n){},c25e:function(e,n,t){"use strict";t.r(n),n["default"]='<blockquote>\n<p>这一篇主要讲讲<code>nextTick</code>源码，看看该方法的实现，以及为何能在这个方法里保证拿到<code>DOM</code>节点。</p>\n</blockquote>\n<p><code>nextTick</code>方法在<code>./src/core/util/next-tick.js</code>，下面为部分源码展示：</p>\n<ol>\n<li><code>nextTick</code>方法接受两个入参，分别是回调方法<code>cb</code>和上下文<code>ctx</code>;</li>\n<li>函数部分逻辑，首先不管是否存在<code>cb</code>参数都会往队列推入一个函数，后续任务队列根据<code>cb</code>参数判断是否调用<code>cb</code>或者是否执行<code>_resolve(ctx)</code>修改<code>promise</code>状态；</li>\n<li>判断<code>pending</code>状态是否执行任务</li>\n<li>最后则是该函数的返回值为一个<code>promise</code></li>\n</ol>\n<pre><code>export function nextTick (cb?: Function, ctx?: Object) {\n  let _resolve\n  callbacks.push(() =&gt; {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e) {\n        handleError(e, ctx, &#39;nextTick&#39;)\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  if (!pending) {\n    pending = true\n    timerFunc()\n  }\n  // $flow-disable-line\n  if (!cb &amp;&amp; typeof Promise !== &#39;undefined&#39;) {\n    return new Promise(resolve =&gt; {\n      _resolve = resolve\n    })\n  }\n}</code></pre><p>先来说说调用<code>nextTick</code>的返回值，因为返回值是一个<code>promise</code>，所以我们可以使用<code>then</code>的写法或者<code>async/await</code>的写法，加上使用<code>cb</code>的写法，存在三种写法。</p>\n<pre><code>this.$nextTick(function() {\n    // do something\n})\n\nor\n\nthis.$nextTick().then((ctx)=&gt; {\n    // do something\n})\n\nor\n\nawait this.$nextTick()\n// do something</code></pre><p>接下来则是<code>nextTick</code>里比较重要的方法<code>timerFunc</code>的实现：</p>\n<ol>\n<li>优先使用原生<code>Promise</code>；</li>\n<li>后使用<code>MutationObserver</code>；</li>\n<li>再后使用<code>setImmediate</code>;</li>\n<li>最后使用<code>setTimeout</code>;</li>\n</ol>\n<pre><code>if (typeof Promise !== &#39;undefined&#39; &amp;&amp; isNative(Promise)) {\n  const p = Promise.resolve()\n  timerFunc = () =&gt; {\n    p.then(flushCallbacks)\n    // In problematic UIWebViews, Promise.then doesn&#39;t completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn&#39;t being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // &quot;force&quot; the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) setTimeout(noop)\n  }\n  isUsingMicroTask = true\n} else if (!isIE &amp;&amp; typeof MutationObserver !== &#39;undefined&#39; &amp;&amp; (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === &#39;[object MutationObserverConstructor]&#39;\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  let counter = 1\n  const observer = new MutationObserver(flushCallbacks)\n  const textNode = document.createTextNode(String(counter))\n  observer.observe(textNode, {\n    characterData: true\n  })\n  timerFunc = () =&gt; {\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n  }\n  isUsingMicroTask = true\n} else if (typeof setImmediate !== &#39;undefined&#39; &amp;&amp; isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Techinically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = () =&gt; {\n    setImmediate(flushCallbacks)\n  }\n} else {\n  // Fallback to setTimeout.\n  timerFunc = () =&gt; {\n    setTimeout(flushCallbacks, 0)\n  }\n}</code></pre><p>从代码中<code>isUsingMicroTask</code>中可以看到只有<code>Promise</code>、<code>MutationObserver</code>属于微任务，另外两个则属于宏任务；看到该方法的实现我们就可以知道为什么在<code>nextTick</code>方法中能保证拿到<code>DOM</code>。</p>\n<p>两种场景的解释：</p>\n<ol>\n<li>在<code>vue</code>第一次初始化的时候，我们在<code>beforeCreated</code>和<code>created</code>生命周期里想要使用<code>DOM</code>则必须使用<code>nextTick</code>，这是因为初始化的过程属于宏任务，整个函数调用栈未清空，<code>nextTick</code>的回调属于微任务，所以<code>nextTick</code>的回调必须在整个初始化结束后才会执行。</li>\n<li>在修改<code>data</code>数据后，又如何保证获取修改后的数据<code>DOM</code>？修改<code>data</code>数据实际上是触发组件实例的<code>watcher</code>执行<code>update</code>更新，而在<code>update</code>里面又执行了<code>queueWatcher</code>，下面👇则是<code>queueWatcher</code>方法的代码，在代码里面我们可以看到最后实际上也是调用<code>nextTick(flushSchedulerQueue)</code>。因此，想获取<code>data</code>修改后的<code>DOM</code>，调用<code>nextTick</code>能保证这种任务执行的顺序。</li>\n</ol>\n<p>了解<code>watcher</code>可以看这篇<a href="https://juejin.im/post/5d181bafe51d457753138219">https://juejin.im/post/5d181bafe51d457753138219</a>。</p>\n<pre><code>export function queueWatcher (watcher: Watcher) {\n  const id = watcher.id\n  if (has[id] == null) {\n    has[id] = true\n    if (!flushing) {\n      queue.push(watcher)\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      let i = queue.length - 1\n      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) {\n        i--\n      }\n      queue.splice(i + 1, 0, watcher)\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n\n      if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !config.async) {\n        flushSchedulerQueue()\n        return\n      }\n      nextTick(flushSchedulerQueue)\n    }\n  }\n}</code></pre><p>其实<code>queueWatcher</code>方法里面的逻辑还告诉了我们另外一个框架知识点：</p>\n<p><strong>为什么我们同时修改多个data属性，不会多次更新视图？</strong></p>\n<p>在<code>update</code>方法里，因为最后实际上调用<code>nextTick</code>执行微任务去更新视图，了解过<code>event loop</code>机制的应该知道，必须等待当前宏任务的调用栈清空才去执行微任务，这也就是为什么当我们同时修改多个<code>data</code>属性时候，该判断<code>if (has[id] == null) </code>防止重复添加更新任务，并且利用了<code>event loop</code>机制在合适的时机去更新视图。</p>\n'},cd78:function(e,n,t){var o=t("e4ae"),r=t("f772"),c=t("656e");e.exports=function(e,n){if(o(e),r(n)&&n.constructor===e)return n;var t=c.f(e),i=t.resolve;return i(n),t.promise}},d424:function(e,n,t){"use strict";t.r(n),n["default"]='<blockquote>\n<p>因为本人开发中使用的是VUE技术栈，最近也是开始源码的学习，以此记录个人理解，若行文有误，请多多指教。</p>\n</blockquote>\n<h2 id="1new-router和install">1.new Router和install</h2>\n<p>在vue中我们使用vue-router时需要先进行<code>new Router()</code>，执行<code>new Router()</code>后主要执行代码看看VueRouter class定义的<code>constructor</code>方法。</p>\n<pre><code>constructor (options: RouterOptions = {}) {\n    this.app = null\n    this.apps = []\n    this.options = options\n    this.beforeHooks = []\n    this.resolveHooks = []\n    this.afterHooks = []\n    this.matcher = createMatcher(options.routes || [], this)\n\n    let mode = options.mode || &#39;hash&#39;\n    this.fallback = mode === &#39;history&#39; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== false\n    if (this.fallback) {\n      mode = &#39;hash&#39;\n    }\n    if (!inBrowser) {\n      mode = &#39;abstract&#39;\n    }\n    this.mode = mode\n\n    switch (mode) {\n      case &#39;history&#39;:\n        this.history = new HTML5History(this, options.base)\n        break\n      case &#39;hash&#39;:\n        this.history = new HashHistory(this, options.base, this.fallback)\n        break\n      case &#39;abstract&#39;:\n        this.history = new AbstractHistory(this, options.base)\n        break\n      default:\n        if (process.env.NODE_ENV !== &#39;production&#39;) {\n          assert(false, `invalid mode: ${mode}`)\n        }\n    }\n  }</code></pre><p>从代码里面我们可以看到在<code>new</code>的时候确定了使用何种路由模式，并且根据传入options创建<code>matcher</code>。</p>\n<p>接下来看看当使用<code>vue.use()</code>执行install方法做了什么：</p>\n<pre><code>export function install (Vue) {\n  if (install.installed &amp;&amp; _Vue === Vue) return\n  install.installed = true\n\n  _Vue = Vue\n\n  const isDef = v =&gt; v !== undefined\n\n  const registerInstance = (vm, callVal) =&gt; {\n    let i = vm.$options._parentVnode\n    if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal)\n    }\n  }\n\n  Vue.mixin({\n    beforeCreate () {\n      if (isDef(this.$options.router)) {\n        this._routerRoot = this\n        this._router = this.$options.router\n        this._router.init(this)\n        Vue.util.defineReactive(this, &#39;_route&#39;, this._router.history.current)\n      } else {\n        this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this\n      }\n      registerInstance(this, this)\n    },\n    destroyed () {\n      registerInstance(this)\n    }\n  })\n\n  Object.defineProperty(Vue.prototype, &#39;$router&#39;, {\n    get () { return this._routerRoot._router }\n  })\n\n  Object.defineProperty(Vue.prototype, &#39;$route&#39;, {\n    get () { return this._routerRoot._route }\n  })\n\n  Vue.component(&#39;RouterView&#39;, View)\n  Vue.component(&#39;RouterLink&#39;, Link)\n\n  const strats = Vue.config.optionMergeStrategies\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created\n}</code></pre><p><code>install</code>方法里主要是<code>Vue.mixin</code>给每个组件混入了<code>beforeCreate</code>和 <code>destroyed </code>方法，在Vue的原型链上增加了<code>$router</code>和<code>$route</code>对象，这就是为什么我们使用Vue的时候在this上可以拿到这两个对象，注册了<code>router-view</code>和<code>router-link</code>两个组件。</p>\n<h2 id="2-matcher和route">2. matcher和route</h2>\n<p>接下来看看<code>matcher</code>的定义：</p>\n<pre><code>export type Matcher = {\n  match: (raw: RawLocation, current?: Route, redirectedFrom?: Location) =&gt; Route;\n  addRoutes: (routes: Array&lt;RouteConfig&gt;) =&gt; void;\n};</code></pre><p><code>matcher</code>暴露了<code>match</code>方法<code>addRoutes</code>方法，从方法的名字上看，match方法是用于路由匹配，addRoutes则是用来添加路由配置。</p>\n<p>在执行<code>creatMatcher()</code>里第一代段代码生成了<code>pathList</code>、<code>pathMap</code>、<code>nameMap</code>这三个对象，这是后面路由执行匹配非常重要的配置。</p>\n<pre><code>  const { pathList, pathMap, nameMap } = createRouteMap(routes)</code></pre><p><code>pathMap</code>和<code>nameMap</code>分别是以route配置的path和name为key生成的一个映射表，对应value为<code>RouteRecord</code>实例。</p>\n<p>下面看看<code>RouteRecord</code>的定义：</p>\n<pre><code>declare type RouteRecord = {\n  path: string;\n  regex: RouteRegExp;\n  components: Dictionary&lt;any&gt;;\n  instances: Dictionary&lt;any&gt;;\n  name: ?string;\n  parent: ?RouteRecord;\n  redirect: ?RedirectOption;\n  matchAs: ?string;\n  beforeEnter: ?NavigationGuard;\n  meta: any;\n  props: boolean | Object | Function | Dictionary&lt;boolean | Object | Function&gt;;\n}</code></pre><p>结合代码里的实际数据对照理解各个属性的含义：</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/6/7/16b318773604a842?w=1598&h=522&f=png&s=132269" alt=""></p>\n<table>\n<thead>\n<tr>\n<th>key</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>path</td>\n<td>传入的路径值</td>\n</tr>\n<tr>\n<td>regex</td>\n<td>根据path生成的正则匹配规则</td>\n</tr>\n<tr>\n<td>components</td>\n<td>path对应的组件</td>\n</tr>\n<tr>\n<td>instances</td>\n<td>执行路由守卫方法时传入的route实例</td>\n</tr>\n<tr>\n<td>name</td>\n<td>route的name</td>\n</tr>\n<tr>\n<td>parent</td>\n<td>route的父级，是一个递归的对象，从最底层一直到最顶层，无则为undefined</td>\n</tr>\n<tr>\n<td>redirect</td>\n<td>重定向的路径</td>\n</tr>\n<tr>\n<td>matchAs</td>\n<td>用于匹配alias</td>\n</tr>\n<tr>\n<td>props</td>\n<td>传入路由的参数</td>\n</tr>\n</tbody></table>\n<p>结合以上解释，我们可以得出<code>vue-router</code>一个大概的运行概念。</p>\n<ol>\n<li><p>执行<code>new Router()</code>生成路由配置对象<code>routedRecord</code></p>\n</li>\n<li><p>路由匹配根据<code>route</code>对象的<code>regex</code>进行匹配</p>\n</li>\n<li><p>根据<code>route</code>的<code>parent</code>对象递归获取<code>component</code>组件生成<code>render Tree</code></p>\n</li>\n<li><p>执行各组件对应的导航守卫方法</p>\n</li>\n</ol>\n<p>此文大概简述了vue-router是如何执行的，但是对于router跳转的具体执行并没有进行深入解释，下一篇文章将会详细说明router跳转之后是如何执行。</p>\n'},d57c:function(e,n,t){"use strict";var o=t("a891"),r=t.n(o);r.a},d6d6:function(e,n,t){"use strict";t.r(n),n["default"]='<blockquote>\n<p>HTTP是我们前端赖以存在的基础，HTTP协议一直在变化，我们又是否真的了解HTTP协议呢？下面一起学习HTTP协议的变化，了解HTTP协议不同版本改进的地方。</p>\n</blockquote>\n<h3 id="http09">HTTP/0.9</h3>\n<p>HTTP/0.9是最早的版本，确认了HTTP基于TCP协议。这个版本只支持GET一个方法，且服务器只能返回HTML格式的字符串。</p>\n<h3 id="http10">HTTP/1.0</h3>\n<p>HTTP-1.0新增了许多内容，包括支持不同类型的响应格式，例如图像、视频等等。新增了HEAD和POST请求方法，补充了响应状态码，权限，缓存等功能。</p>\n<h3 id="http11">HTTP/1.1</h3>\n<p>HTTP/1.1引入了持久链接以及管道机制。</p>\n<h3 id="http20">HTTP/2.0</h3>\n<p>HTTP/2.0引入了二进制，多路复用，服务器推送（socket），数据流和头信息压缩优化。</p>\n<h3 id="http30">HTTP/3.0</h3>\n<p>HTTP/3.0据说引入了新的协议（QUIC），该协议解决了以前TCP协议所存在的问题，并且极大的提升了性能与安全性。</p>\n<h3 id="不同版本解决的问题">不同版本解决的问题</h3>\n<h4 id="09----10">0.9 --&gt; 1.0</h4>\n<p>从0.9到1.0版本，HTTP协议的变化极大丰富了前端页面可以交互的内容，在最早的时候可能我们所看到的只有一个纯文本的页面，但是到了1.0版本，新增了图像、音频等新的响应内容，前端可交互的内容变得更加丰富了。</p>\n<h4 id="10----11">1.0 --&gt; 1.1</h4>\n<p>在1.0版本，因为每个TCP只能发送一个请求，发送数据之后连接就会关闭；每次发送新的请求就需要建立一个新的连接，而建立一个新的连接成本非常高昂，由此产生了<font color=red size=4>连接无法复用</font>的问题，存在性能问题。1.1版本引入的持久连接允许一个请求在数据返回之后保留一段时间，和管道机制允许我们同时发送多个请求。</p>\n<h3 id="11----20">1.1 --&gt; 2.0</h3>\n<p>在1.1版本引入的管道机制允许我们同时发送多个请求，例如同时发送A和B请求，但是服务器还是会按照顺序先处理A请求，等A响应后再处理B请求，由此产生了我们所说的<font color=red size=4>线头阻塞（Head-of-line blocking）</font>问题。如果第一个响应处理非常久，则会导致后面的请求必须等待前面的请求处理完之后才能得到响应。</p>\n<p>所以在2.0版本引入的多路复用和数据流允许我们不会受到前面处理非常耗时的请求影响，可以分优先级处理响应。同时引入了服务器推送（socket）增加了客户端与服务器双向通信的能力。</p>\n'},dcab:function(e,n,t){var o={"./CSS容易忽略的一些知识点.md":["83db"],"./HTTP协议从0.9-2.0的变化.md":["d6d6"],"./ 理解JS的event loop.md":["a522"],"./一篇文章带你理解HTTP缓存.md":["b8c8"],"./前端的安全问题与防御策略.md":["1dd9"],"./前端跨域的解决方案.md":["69b0"],"./学习node Assert + mocha + should断言测试，travis-CI持续集成项目.md":["8bff"],"./学习valueOf和toString，理解隐式转化规则.md":["9346"],"./学习vue-router源码记录-1.md":["d424"],"./学习vue-router源码记录-2.md":["24f8"],"./学习vue-router源码记录-3.md":["9c25"],"./学习vuex源码.md":["6214"],"./学习vue源码—mvvm.md":["63b7"],"./学习vue源码—nextTick.md":["c25e"],"./学习vue源码—vue-diff.md":["f45e"],"./学习观察者模式与发布-订阅模式.md":["0ec7"],"./深入学习正则表达式.md":["b0f1"],"./理解__proto__和prototype.md":["26a0"],"./重新认识前端开发使用的『图片』.md":["112e"]};function r(e){var n=o[e];return n?Promise.all(n.slice(1).map(t.e)).then(function(){var e=n[0];return t(e)}):Promise.resolve().then(function(){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n})}r.keys=function(){return Object.keys(o)},r.id="dcab",e.exports=r},e628:function(e,n,t){"use strict";t.r(n);var o=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",[t("nav-bar",{attrs:{title:"文章内容","left-text":"返回","left-arrow":"","is-fix":""},on:{"click-left":e.goBack}}),t("div",{staticClass:"article-box"},[t("h3",{staticClass:"article-title"},[e._v(e._s(e.title))]),t("div",{staticClass:"article-body",domProps:{innerHTML:e._s(e.content)}})])],1)},r=[],c=(t("96cf"),t("795b")),i=t.n(c);function d(e,n,t,o,r,c,d){try{var s=e[c](d),a=s.value}catch(l){return void t(l)}s.done?n(a):i.a.resolve(a).then(o,r)}function s(e){return function(){var n=this,t=arguments;return new i.a(function(o,r){var c=e.apply(n,t);function i(e){d(c,o,r,i,s,"next",e)}function s(e){d(c,o,r,i,s,"throw",e)}i(void 0)})}}var a={name:"Blog-Content",data:function(){return{title:"",content:""}},beforeRouteEnter:function(e,n,o){o(function(){var n=s(regeneratorRuntime.mark(function n(o){var r;return regeneratorRuntime.wrap(function(n){while(1)switch(n.prev=n.next){case 0:return o.title=e.params.url,n.next=3,t("dcab")("./".concat(e.params.url,".md"));case 3:r=n.sent,o.content=r.default;case 5:case"end":return n.stop()}},n)}));return function(e){return n.apply(this,arguments)}}())},methods:{goBack:function(){this.$router.push("/blog/list")}}},l=a,p=(t("d57c"),t("a0c2"),t("2877")),u=Object(p["a"])(l,o,r,!1,null,"1021a27a",null);n["default"]=u.exports},f201:function(e,n,t){var o=t("e4ae"),r=t("79aa"),c=t("5168")("species");e.exports=function(e,n){var t,i=o(e).constructor;return void 0===i||void 0==(t=o(i)[c])?n:r(t)}},f45e:function(e,n,t){"use strict";t.r(n),n["default"]='<blockquote>\n<p>本文主要记录vue-diff的原理以及说明一个响应式数据更新的流程是怎么样的一个过程。</p>\n</blockquote>\n<h2 id="1-数据改变到页面渲染的过程是怎么样的？">1. 数据改变到页面渲染的过程是怎么样的？</h2>\n<p>首先看下面的图片👇，这是执行click函数改变一个数据之后发生的函数调用栈，从图上的说明可以比较清楚个了解这个响应式过程的大概流程。下面简单讲解一下：</p>\n<ol>\n<li>改变数据，触发这个被劫持过的数据的<code>setter</code>方法</li>\n<li>执行这个数据的订阅中心（<code>dep</code>）的<code>notify</code>方法</li>\n<li><code>update</code>方法里执行<code>queueWatcher</code>方法把<code>watcher</code>推入队列</li>\n<li>执行<code>nextTick</code>方法开始更新视图</li>\n<li><code>run</code>方法里设置<code>dep.target</code>为当前订阅对象</li>\n<li>调用<code>get</code>方法调用当前<code>watcher</code>的<code>getter</code>执行更新方法</li>\n<li><code>updateComponent</code>方法里调用了<code>render</code>方法开始执行渲染页面</li>\n<li><code>patch</code>、<code>patchVnode</code>、<code>updateChildren</code>方法都是比较VNode更新渲染的函数，不过重点的diff过程在<code>updateChildren</code>方法里。\n<img src="https://user-gold-cdn.xitu.io/2019/6/23/16b83a2e38faea15?w=1016&h=1066&f=png&s=181273" alt=""></li>\n</ol>\n<h2 id="2-vue-diff的具体实现">2. vue-diff的具体实现</h2>\n<p><code>patchVnode</code>、<code>updateChildren</code>方法在vue源码项目的<code>src/core/vdom/patch.js</code>文件中。</p>\n<p>先介绍<code>patchVnode</code>方法，这是执行真正更新dom的方法，大概的执行逻辑如下</p>\n<ol>\n<li>判断vnode和oldVnode是否相等</li>\n<li>判断是否能重用vnode</li>\n<li>判断是否执行回调</li>\n<li>判断是否有children需要diff更新</li>\n<li>判断执行更新类型—新增dom、移除dom、更新textDom</li>\n</ol>\n<pre><code>  function patchVnode (\n    oldVnode,\n    vnode,\n    insertedVnodeQueue,\n    ownerArray,\n    index,\n    removeOnly\n  ) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode)\n    }\n\n    const elm = vnode.elm = oldVnode.elm\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue)\n      } else {\n        vnode.isAsyncPlaceholder = true\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &amp;&amp;\n      isTrue(oldVnode.isStatic) &amp;&amp;\n      vnode.key === oldVnode.key &amp;&amp;\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance\n      return\n    }\n\n    let i\n    const data = vnode.data\n    if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) {\n      i(oldVnode, vnode)\n    }\n\n    const oldCh = oldVnode.children\n    const ch = vnode.children\n    if (isDef(data) &amp;&amp; isPatchable(vnode)) {\n      for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)\n      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode)\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) &amp;&amp; isDef(ch)) {\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n      } else if (isDef(ch)) {\n        if (process.env.NODE_ENV !== &#39;production&#39;) {\n          checkDuplicateKeys(ch)\n        }\n        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#39;&#39;)\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n      } else if (isDef(oldCh)) {\n        removeVnodes(oldCh, 0, oldCh.length - 1)\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, &#39;&#39;)\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text)\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)\n    }\n  }</code></pre><p>接下来就是我们经常说的vue-diff所在的方法<code>updateChildren</code>，先从参数说起，分别是父元素dom，旧的vnode-list，新的vnode-list，需要插入的vnode队列，是否仅移除。</p>\n<p>重点的逻辑在<code>while</code>循环里：</p>\n<p>如何理解这个diff逻辑，其实是分别有新旧两个vnode-list，两个list都设定第一位和最后一位作为两个游标，通过一系列判断对比，不断逼近，当两个list的两个游标相交则循环结束。</p>\n<p>至于具体判断的逻辑就不赘述了，代码已经写得非常清楚了，在这里比较有意思的<code>sameVnode</code>的判断，在使用<code>v-for</code>生成的vnode-list不设置<code>key</code>的时候，所有的对比更新几乎都会从第三和第四个判断分支进行，即代码中的<code>sameVnode(oldStartVnode, newStartVnode)</code>和<code>sameVnode(oldEndVnode, newEndVnode)</code>判断，下面看看<code>sameVnode</code>的方法，当我们不设置key的时候，判断的逻辑会通过tag类型和vnode的数据某些属性进行比较，通常来说都是相同的，这就是官方文档说的<font color=red>原地复用</font>逻辑，直接更新当前节点的内容，不需要对当前的节点进行移动。这对于节点内容相对简单的来说默认会更高效，但是当节点内容相对复杂的时候我们就需要对节点内容进行复用而不是重新生成，这时候我们就需要设置<code>key</code>来复用节点。</p>\n<p>最后的一段判断<code>oldStartIdx > oldEndIdx</code>和<code>newStartIdx > newEndIdx</code>则说明符合这两个条件的时候我们当前vnode-list是从无到有或从有到无的变化。</p>\n<p>图示：官方文档的说明（👇）</p>\n<p><img src="https://user-gold-cdn.xitu.io/2019/6/23/16b84467afb18dfd?w=1458&h=632&f=png&s=186334" alt=""></p>\n<p><code>sameVnode</code>方法定义</p>\n<pre><code>function sameVnode (a, b) {\n  return (\n    a.key === b.key &amp;&amp; (\n      (\n        a.tag === b.tag &amp;&amp;\n        a.isComment === b.isComment &amp;&amp;\n        isDef(a.data) === isDef(b.data) &amp;&amp;\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &amp;&amp;\n        a.asyncFactory === b.asyncFactory &amp;&amp;\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}</code></pre><p><code>updateChildren</code>方法定义</p>\n<pre><code>  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    let oldStartIdx = 0\n    let newStartIdx = 0\n    let oldEndIdx = oldCh.length - 1\n    let oldStartVnode = oldCh[0]\n    let oldEndVnode = oldCh[oldEndIdx]\n    let newEndIdx = newCh.length - 1\n    let newStartVnode = newCh[0]\n    let newEndVnode = newCh[newEndIdx]\n    let oldKeyToIdx, idxInOld, vnodeToMove, refElm\n\n    // removeOnly is a special flag used only by &lt;transition-group&gt;\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    const canMove = !removeOnly\n\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      checkDuplicateKeys(newCh)\n    }\n\n    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx]\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        oldStartVnode = oldCh[++oldStartIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)\n        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        oldStartVnode = oldCh[++oldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n        canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[++newStartIdx]\n      } else {\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n        } else {\n          vnodeToMove = oldCh[idxInOld]\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)\n            oldCh[idxInOld] = undefined\n            canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)\n          }\n        }\n        newStartVnode = newCh[++newStartIdx]\n      }\n    }\n    if (oldStartIdx &gt; oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n    } else if (newStartIdx &gt; newEndIdx) {\n      removeVnodes(oldCh, oldStartIdx, oldEndIdx)\n    }\n  }</code></pre><h2 id="总结">总结</h2>\n<p>其实vue-diff的算法并不复杂，代码阅读起来也相对容易。在vue里从patch到视图的变化是实时的，即假如存在3个节点变化，vue并不是收集完所有的patch再一次性更新视图，而是在遍历diff的过程中patch直接更新视图。</p>\n'},f850:function(e,n,t){"use strict";t.r(n);var o=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"blog-list-box"},[t("nav-bar",{attrs:{title:"文章列表","left-text":"返回","left-arrow":"","is-fix":""},on:{"click-left":e.goBack}}),t("ul",{staticClass:"article-list"},e._l(e.markdownList,function(n,o){return t("li",{key:o,on:{click:function(t){return e.getContent(n)}}},[e._v("\n            "+e._s(n.title)+"\n        ")])}),0)],1)},r=[],c=t("ed08"),i=Object(c["a"])(t("1c4f")),d=i,s={name:"Blog-List",data:function(){return{markdownList:d}},methods:{getContent:function(e){this.$router.push("/blog/content/".concat(e.title))},goBack:function(){this.$router.push("/user")}}},a=s,l=(t("7456"),t("2877")),p=Object(l["a"])(a,o,r,!1,null,"13012e19",null);n["default"]=p.exports}}]);
//# sourceMappingURL=blog.4cb1e1b0.js.map